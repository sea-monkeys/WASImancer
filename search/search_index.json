{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83e\uddd9\ud83c\udffb\u200d\u2642\ufe0f WASImancer","text":"<p>A WebAssembly-Powered MCP StreamableHTTP Server</p>"},{"location":"#what-is-wasimancer","title":"What is WASImancer?","text":"<p>WASImancer is an innovative Model Context Protocol (MCP) server built with Node.js that enhances AI tool execution through WebAssembly plugins. By leveraging the Extism framework, it enables seamless integration of WebAssembly modules as plugin functions, creating a flexible and powerful environment for model interactions.</p>"},{"location":"#why-use-wasimancer","title":"Why Use WASImancer?","text":""},{"location":"#distributed-architecture-with-sse-transport","title":"Distributed Architecture with SSE Transport","text":"<p>Unlike traditional MCP servers that use STDIO transport (requiring installation on the same machine as your AI application), WASImancer uses StreamableHTTP transport, enabling a distributed architecture where:</p> <ul> <li>A single WASImancer instance can serve multiple AI applications across different machines</li> <li>Applications can access tools, resources, and prompts remotely</li> <li>You gain simplified deployment and management through centralization</li> </ul> <pre><code>graph TD\n    subgraph \"Workstation A\"\n        MCP[MCP StreamableHTTP Server]\n    end\n\n    subgraph \"Workstation B\"\n        ChatBot1[ChatBot 1]\n    end\n\n    subgraph \"Workstation C\"\n        ChatBot2[ChatBot 2]\n    end\n\n    subgraph \"Workstation D\"\n        ChatBot3[ChatBot 3]\n    end\n\n    ChatBot1 --&gt;|API Requests| MCP\n    ChatBot2 --&gt;|API Requests| MCP\n    ChatBot3 --&gt;|API Requests| MCP\n\n    MCP --&gt;|Responses| ChatBot1\n    MCP --&gt;|Responses| ChatBot2\n    MCP --&gt;|Responses| ChatBot3\n\n    style MCP fill:#f96,stroke:#333,stroke-width:2px\n    style ChatBot1 fill:#bbf,stroke:#333,stroke-width:1px\n    style ChatBot2 fill:#bbf,stroke:#333,stroke-width:1px\n    style ChatBot3 fill:#bbf,stroke:#333,stroke-width:1px</code></pre>"},{"location":"#webassembly-powered-tools","title":"WebAssembly-Powered Tools","text":"<p>What makes WASImancer special is its ability to load and execute tools as WebAssembly plugin functions, providing:</p> <ul> <li>Performance: Near-native execution speed for your tools</li> <li>Language Agnosticism: Write plugins in Go, Rust, C++, or any language that compiles to WebAssembly</li> <li>Security: Sandboxed execution environment for your code</li> <li>Extensibility: Dynamically add, remove, or update plugins without server restarts</li> </ul>"},{"location":"#hot-reloading-and-api-driven-management","title":"Hot-Reloading and API-Driven Management","text":"<p>WASImancer enables:</p> <ul> <li>Dynamic Plugin Management: Upload, update, or remove WebAssembly plugins via API calls</li> <li>Zero Downtime Updates: Add new functionality without restarting the server</li> <li>Easy Testing: Quickly iterate on tool development and instantly test changes</li> </ul>"},{"location":"#configuration-driven-setup","title":"Configuration-Driven Setup","text":"<p>Set up your MCP environment using simple YAML files:</p> <ul> <li>plugins.yml: Define your WebAssembly tools and their functions</li> <li>resources.yml: Configure static contextual information</li> <li>prompts.yml: Create templated prompts with variable substitution</li> </ul>"},{"location":"#authentication-and-admin-tokens","title":"Authentication and Admin tokens","text":"<p>WASImancer needs two tokens, and you can set these two tokens with environment variables:</p> <ol> <li>A bearer authentication token to protect the SSE endpoints (the communications between the MCP Client and the MCP Server), use <code>WASIMANCER_AUTHENTICATION_TOKEN=mcp-is-the-way</code> (if you want to disable the authentication, set it to <code>NO_AUTHENTICATION</code>).</li> <li>A bearer admin token to protect the prompts, ressources and tools management endpoints (eg: uploading a new tool, removing a resource...), use <code>WASIMANCER_ADMIN_TOKEN=wasimancer-rocks</code></li> </ol> <p>\u270b If you don't set these tokens, the server will generate them for you at evry start (Look at the logs). You can use them to test the server, but you should set your own tokens for production.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>The simplest way to start using WASImancer is with Docker:</p> <pre><code>docker run --rm -p 3001:3001 \\\n  -e HTTP_PORT=3001 \\\n  -e PLUGINS_PATH=./plugins \\\n  -e PLUGINS_DEFINITION_FILE=plugins.yml \\\n  -v \"$(pwd)/plugins\":/app/plugins \\\n  -e RESOURCES_PATH=./resources \\\n  -e RESOURCES_DEFINITION_FILE=resources.yml \\\n  -v \"$(pwd)/resources\":/app/resources \\\n  -e PROMPTS_PATH=./prompts \\\n  -e PROMPTS_DEFINITION_FILE=prompts.yml \\\n  -v \"$(pwd)/prompts\":/app/prompts \\\n  -e WASIMANCER_ADMIN_TOKEN=wasimancer-rocks \\\n  -e WASIMANCER_AUTHENTICATION_TOKEN=mcp-is-the-way \\\n  -e UPLOAD_PATH=./plugins/bucket \\\n  k33g/wasimancer:0.0.7 \n</code></pre> <p>Or with Docker Compose:</p> <pre><code>services:  \n  wasimancer-server:\n    image: k33g/wasimancer:0.0.7\n    environment:\n      - HTTP_PORT=3001\n      - PLUGINS_PATH=./plugins\n      - PLUGINS_DEFINITION_FILE=plugins.yml\n      - RESOURCES_PATH=./resources\n      - RESOURCES_DEFINITION_FILE=resources.yml\n      - PROMPTS_PATH=./prompts\n      - PROMPTS_DEFINITION_FILE=prompts.yml\n      - WASIMANCER_ADMIN_TOKEN=wasimancer-rocks\n      - WASIMANCER_AUTHENTICATION_TOKEN=mcp-is-the-way\n      - UPLOAD_PATH=./plugins/bucket\n    ports:\n      - 3001:3001\n    volumes:\n      - ./resources:/app/resources\n      - ./plugins:/app/plugins\n      - ./prompts:/app/prompts\n</code></pre>"},{"location":"#use-cases","title":"Use Cases","text":"<p>WASImancer is ideal for:</p> <ol> <li>AI-Powered Applications: Enable large language models to interact with external systems and data through tools</li> <li>Distributed Architectures: Serve multiple AI applications from a central tool server</li> <li>Rapid Prototyping: Quickly develop and test new AI tool capabilities</li> <li>Cross-Language Integration: Bridge language barriers by compiling tools from any language to WebAssembly</li> <li>Secure Tool Execution: Run untrusted code in a sandboxed environment</li> </ol>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Explore the examples and plugins directories for sample implementations</li> <li>Learn how to develop your own plugins in Go</li> <li>Learn how to develop your own plugins in Rust</li> <li>Check out the Inspector tool to interact with your WASImancer server</li> </ul> <p>Think of WASImancer as a bridge between the MCP ecosystem and the vast possibilities of WebAssembly, allowing developers to write plugins in their preferred language while maintaining high performance and security in a distributed architecture.</p>"},{"location":"configuration-date-for-plugins/","title":"Pass configuration data at start to the plugin","text":"<p>\ud83d\udea7 work in progress</p> <p>If you create environment variables starting by <code>WASM_</code>, for example <code>WASM_VERSION=0.0.1</code>, <code>WASM_MESSAGE=wasm plugins are the way</code>, the variables values will be available in the wasm plugin with the <code>pdk.GetConfig()</code> method:</p> <pre><code>version,_ := pdk.GetConfig(\"WASM_VERSION\")\nmessage,_ := pdk.GetConfig(\"WASM_MESSAGE\")\n</code></pre>"},{"location":"dynamic-resources-guide/","title":"WASImancer Dynamic Resources","text":"<p>\ud83d\udea7 work in progress</p>"},{"location":"dynamic-resources-guide/#introduction-to-dynamic-resources","title":"Introduction to Dynamic Resources","text":"<p>Dynamic resources in WASImancer are template-based resources that can accept arguments through URI templates. Unlike static resources which have fixed content, dynamic resources can generate different content based on the parameters provided in the request URI.</p>"},{"location":"dynamic-resources-guide/#defining-dynamic-resources","title":"Defining Dynamic Resources","text":"<p>Dynamic resources are defined in your <code>resources.yml</code> file under the <code>dynamic</code> section:</p> <pre><code>resources:\n  dynamic:\n    - name: echo\n      uri: echo://{message}\n      arguments:\n        - name: 'message'\n          type: 'string' # for informational purposes only\n      contents:\n        - text: 'Resource echo: ${message}'\n</code></pre>"},{"location":"dynamic-resources-guide/#configuration-properties","title":"Configuration Properties:","text":"<ul> <li><code>name</code>: A unique identifier for the resource</li> <li><code>uri</code>: A URI template with variables in curly braces (e.g., <code>echo://{message}</code>)</li> <li><code>arguments</code>: An array defining each argument the resource accepts:</li> <li><code>name</code>: The argument name (must match the variable in the URI template)</li> <li><code>type</code>: The argument type (string, number, boolean, etc.) \u270b for informational purposes only</li> <li><code>contents</code>: An array of content templates where the actual values can be referenced using <code>${variableName}</code> syntax</li> </ul>"},{"location":"dynamic-resources-guide/#how-uri-templates-work","title":"How URI Templates Work","text":"<p>URI templates allow you to define a pattern for your resource URIs with placeholder variables:</p> <ol> <li>Variables are defined using curly braces: <code>{variableName}</code></li> <li>When a client requests the resource, the actual values are extracted from the URI</li> <li>These values are then available to use in your content using the <code>${variableName}</code> syntax</li> </ol>"},{"location":"dynamic-resources-guide/#examples","title":"Examples","text":""},{"location":"dynamic-resources-guide/#basic-example-echo-resource","title":"Basic Example: Echo Resource","text":"<pre><code>dynamic:\n  - name: echo\n    uri: echo://{message}\n    arguments:\n      - name: 'message'\n        type: 'string'\n    contents:\n      - text: 'Resource echo: ${message}'\n</code></pre> <p>When a client requests <code>echo://hello_world</code>, the server responds with: <pre><code>Resource echo: hello_world\n</code></pre></p>"},{"location":"dynamic-resources-guide/#multiple-parameters-greeting-resource","title":"Multiple Parameters: Greeting Resource","text":"<pre><code>dynamic:\n  - name: greeting\n    uri: greeting://{name}/{language}\n    arguments:\n      - name: 'name'\n        type: 'string'\n      - name: 'language'\n        type: 'string'\n    contents:\n      - text: 'Hello ${name} in ${language}!'\n</code></pre> <p>When a client requests <code>greeting://John/Spanish</code>, the server responds with: <pre><code>Hello John in Spanish!\n</code></pre></p>"},{"location":"dynamic-resources-guide/#summary","title":"Summary","text":"<p>Dynamic resources in WASImancer provide a powerful way to create flexible, parameterized resources that can generate different content based on user input. By using URI templates and argument definitions, you can create resources that respond dynamically to different requests.</p>"},{"location":"go-plugin-guide/","title":"Creating Go Plugins for WASImancer: A Step-by-Step Guide","text":"<p>\ud83d\udea7 work in progress</p> <p>This guide will walk you through the process of creating, building, and running a WebAssembly plugin for WASImancer using Go. We'll create a simple plugin that generates random character names.</p>"},{"location":"go-plugin-guide/#prerequisites","title":"Prerequisites","text":"<p>To follow this guide, you'll need:</p> <ul> <li>Go (1.18 or newer) installed</li> <li>TinyGo installed (required for WebAssembly compilation)</li> <li>Extism CLI installed (for testing)</li> </ul> <p>Alternatively, you can use the Docker image provided by WASImancer: <pre><code>docker pull k33g/wasm-builder:0.0.7\n</code></pre></p>"},{"location":"go-plugin-guide/#project-setup","title":"Project Setup","text":"<p>Let's create a new plugin project:</p> <pre><code>mkdir -p character-name-generator\ncd character-name-generator\n</code></pre>"},{"location":"go-plugin-guide/#creating-the-go-module","title":"Creating the Go Module","text":"<p>Initialize a new Go module:</p> <pre><code>go mod init character-name-generator\n</code></pre> <p>Add the Extism PDK (Plugin Development Kit) as a dependency:</p> <pre><code>go get github.com/extism/go-pdk\n</code></pre>"},{"location":"go-plugin-guide/#writing-the-plugin-code","title":"Writing the Plugin Code","text":"<p>Create a file named <code>main.go</code> with the following content:</p> <pre><code>package main\n\nimport (\n    \"math/rand\"\n    \"time\"\n\n    \"github.com/extism/go-pdk\"\n)\n\n// Word lists for generating character names\nvar (\n    adjectives = []string{\n        \"admirable\", \"brave\", \"charming\", \"determined\", \"elegant\", \"fantastic\", \"graceful\",\n        \"heroic\", \"inspiring\", \"jolly\", \"kind\", \"loyal\", \"majestic\", \"noble\",\n        \"optimistic\", \"peaceful\", \"quirky\", \"resilient\", \"serene\", \"tenacious\", \"unique\",\n        \"valiant\", \"wonderful\", \"xenial\", \"zealous\", \"agile\", \"brilliant\", \"curious\",\n        \"daring\", \"energetic\", \"fierce\", \"generous\", \"honest\", \"imaginative\", \"jovial\",\n    }\n\n    nouns = []string{\n        \"eagle\", \"whale\", \"hummingbird\", \"dolphin\", \"elephant\", \"falcon\", \"gorilla\",\n        \"owl\", \"iguana\", \"jaguar\", \"koala\", \"leopard\", \"medusa\", \"narwhal\",\n        \"orca\", \"panther\", \"quokka\", \"raccoon\", \"salamander\", \"tiger\", \"unicorn\",\n        \"vulture\", \"wombat\", \"xerus\", \"yak\", \"zebra\", \"albatross\", \"bison\", \"chameleon\",\n        \"dragon\", \"squirrel\", \"flamingo\", \"gazelle\", \"hippocampus\", \"ibis\",\n    }\n)\n\n//export GenerateCharacterName\nfunc GenerateCharacterName() {\n    // Initialize random number generator with a time-based seed\n    r := rand.New(rand.NewSource(time.Now().UnixNano()))\n\n    // Select a random adjective and noun\n    adj := adjectives[r.Intn(len(adjectives))]\n    noun := nouns[r.Intn(len(nouns))]\n\n    // Combine with a hyphen, GitHub-style\n    output := adj + \"-\" + noun\n\n    // Return the value to the host\n    mem := pdk.AllocateString(output)\n    pdk.OutputMemory(mem)\n}\n\nfunc main() {\n    // Empty main function required for compilation\n}\n</code></pre>"},{"location":"go-plugin-guide/#understanding-the-code","title":"Understanding the Code","text":"<ol> <li> <p>We import the <code>github.com/extism/go-pdk</code> package, which provides the interface between our Go code and the WebAssembly host environment.</p> </li> <li> <p>We define two slices of strings: <code>adjectives</code> and <code>nouns</code>, which will be used to generate random character names.</p> </li> <li> <p>We define a function <code>GenerateCharacterName</code> with the <code>//export</code> comment, which marks this function as exportable from the WebAssembly module.</p> </li> <li> <p>Inside the function, we:</p> </li> <li>Initialize a random number generator</li> <li>Select a random adjective and noun</li> <li>Combine them with a hyphen to create a character name</li> <li> <p>Allocate memory for the string and output it to the host</p> </li> <li> <p>The <code>main()</code> function is empty but required for compilation.</p> </li> </ol>"},{"location":"go-plugin-guide/#building-the-plugin","title":"Building the Plugin","text":""},{"location":"go-plugin-guide/#using-local-tinygo","title":"Using Local TinyGo","text":"<p>To compile your Go code to WebAssembly, run:</p> <pre><code>tinygo build -scheduler=none --no-debug \\\n  -o character-name-generator.wasm \\\n  -target wasi main.go\n</code></pre>"},{"location":"go-plugin-guide/#using-docker","title":"Using Docker","text":"<p>If you're using the WASImancer's Docker image:</p> <pre><code>docker run --rm -v \"$PWD\":/character-name-generator -w /character-name-generator k33g/wasm-builder:0.0.7 \\\n  tinygo build -scheduler=none --no-debug \\\n    -o character-name-generator.wasm \\\n    -target wasi main.go\n</code></pre> <p>This will create a file called <code>character-name-generator.wasm</code> in your project directory.</p>"},{"location":"go-plugin-guide/#testing-the-plugin-locally","title":"Testing the Plugin Locally","text":"<p>You can test your plugin using the Extism CLI before deploying it to WASImancer:</p>"},{"location":"go-plugin-guide/#using-local-extism-cli","title":"Using Local Extism CLI","text":"<pre><code>extism call character-name-generator.wasm GenerateCharacterName --wasi\n</code></pre>"},{"location":"go-plugin-guide/#using-docker_1","title":"Using Docker","text":"<pre><code>docker run --rm -v \"$PWD\":/character-name-generator -w /character-name-generator k33g/wasm-builder:0.0.7 \\\n  extism call character-name-generator.wasm GenerateCharacterName --wasi\n</code></pre> <p>You should see a randomly generated character name as output, like <code>brave-dolphin</code> or <code>tenacious-dragon</code>.</p>"},{"location":"go-plugin-guide/#creating-the-plugin-configuration","title":"Creating the Plugin Configuration","text":"<p>To use your plugin with WASImancer, you need to create a configuration in the <code>plugins.yml</code> file. Add the following entry:</p> <pre><code>plugins:\n  - name: character-name-generator\n    path: ./bucket/character-name-generator.wasm\n    version: 1.0.0\n    description: a character name generator\n    functions:\n      - displayName: GenerateCharacterName\n        function: GenerateCharacterName\n        arguments: []\n        description: a function to generate a character name\n</code></pre>"},{"location":"go-plugin-guide/#deploying-the-plugin-to-wasimancer","title":"Deploying the Plugin to WASImancer","text":""},{"location":"go-plugin-guide/#method-1-manual-deployment","title":"Method 1: Manual Deployment","text":"<ol> <li> <p>Copy your WebAssembly file to the WASImancer plugins directory:    <pre><code>cp character-name-generator.wasm /path/to/wasimancer/plugins/bucket/\n</code></pre></p> </li> <li> <p>Restart WASImancer or use the hot-reload API (next method).</p> </li> </ol>"},{"location":"go-plugin-guide/#method-2-using-the-upload-api","title":"Method 2: Using the Upload API","text":"<p>You can use the WASImancer API to upload your plugin without restarting the server:</p> <ol> <li>Create a shell script named <code>publish.sh</code> with the following content:</li> </ol> <pre><code>#!/bin/bash\nTOKEN=\"wasimancer-rocks\"  # Use your configured token\n\nUPLOAD_ENDPOINT=\"http://localhost:3001/upload-plugin\"\nWASM_FILE=\"./character-name-generator.wasm\"\n\nread -r -d '' DATA &lt;&lt;- EOM\n{\n  \"name\": \"character-name-generator\",\n  \"path\": \"./bucket/character-name-generator.wasm\",\n  \"version\": \"1.0.0\",\n  \"description\": \"a character name generator\",\n  \"functions\": [\n    {\n      \"displayName\": \"GenerateCharacterName\",\n      \"function\": \"GenerateCharacterName\",\n      \"arguments\": [],\n      \"description\": \"a function to generate a character name\"\n    }\n  ]\n}\nEOM\n\ncurl -X POST ${UPLOAD_ENDPOINT} \\\n  -H \"Authorization: Bearer ${TOKEN}\" \\\n  -F \"wasmFile=@${WASM_FILE}\" \\\n  -F \"pluginData=${DATA}\"\n</code></pre> <ol> <li>Make the script executable and run it:    <pre><code>chmod +x publish.sh\n./publish.sh\n</code></pre></li> </ol>"},{"location":"go-plugin-guide/#testing-the-plugin-in-wasimancer","title":"Testing the Plugin in WASImancer","text":"<p>You can test your deployed plugin using the MCP Inspector:</p> <ol> <li> <p>Start the Inspector:    <pre><code>npx @modelcontextprotocol/inspector\n</code></pre></p> </li> <li> <p>Connect to your WASImancer instance (typically at <code>http://localhost:3001/sse</code>).</p> </li> <li> <p>Navigate to the \"Tools\" tab, find your plugin, and click \"Run Tool\".</p> </li> </ol>"},{"location":"go-plugin-guide/#debugging-tips","title":"Debugging Tips","text":"<ol> <li> <p>Use Simple Data Types: Start with simple data types like strings and integers.</p> </li> <li> <p>Print to Console: The PDK provides functions for debug logging:    <pre><code>pdk.Log(pdk.LogDebug, \"Debug message\")\npdk.Log(pdk.LogInfo, \"Info message\")\npdk.Log(pdk.LogError, \"Error message\")\n</code></pre></p> </li> <li> <p>Test Incrementally: Build and test your plugin after each small change.</p> </li> <li> <p>Check Return Values: Always validate the data returned by your functions.</p> </li> </ol>"},{"location":"go-plugin-guide/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Error Handling: Always handle errors and provide meaningful error messages.</p> </li> <li> <p>Input Validation: Validate all input arguments before processing.</p> </li> <li> <p>Memory Management: The PDK handles memory allocation, but be conscious of large data structures.</p> </li> <li> <p>Statelessness: Design your plugins to be stateless whenever possible.</p> </li> <li> <p>Documentation: Comment your code and provide clear descriptions in your plugin configuration.</p> </li> </ol>"},{"location":"go-plugin-guide/#conclusion","title":"Conclusion","text":"<p>You've now learned how to create, build, test, and deploy a Go plugin for WASImancer. By leveraging Go's performance and the WebAssembly sandbox, you can create powerful, secure tools that enhance your AI applications through the Model Context Protocol.</p>"},{"location":"langchainjs-guide/","title":"MCP StreamableHTTP client and LangchainJS","text":"<p>\ud83d\udea7 work in progress</p>"},{"location":"langchainjs-guide/#overview","title":"Overview","text":"<p>See this examples:</p> <ul> <li><code>examples/roll-dice-project</code> </li> <li><code>examples/pizzerias</code></li> </ul>"},{"location":"plugins-rest-api-guide/","title":"WASImancer Plugin Management API Guide","text":"<p>\ud83d\udea7 work in progress</p> <p>This guide explains how to use WASImancer's REST API to dynamically publish, update, and remove WebAssembly plugins without restarting the server.</p>"},{"location":"plugins-rest-api-guide/#overview","title":"Overview","text":"<p>WASImancer provides a REST API that enables:</p> <ul> <li>Publishing new plugins - Upload WebAssembly modules and register them as tools</li> <li>Updating existing plugins - Replace a plugin's implementation while preserving its interface</li> <li>Removing plugins - Unregister and delete plugins that are no longer needed</li> </ul> <p>These operations allow you to manage your MCP server's capabilities at runtime without service interruption.</p>"},{"location":"plugins-rest-api-guide/#administration-authentication","title":"Administration authentication","text":"<p>All Administration API endpoints require authentication using a Bearer token. This token is configured when starting the WASImancer server using the <code>WASIMANCER_ADMIN_TOKEN</code> environment variable:</p> <pre><code>environment:\n  - WASIMANCER_ADMIN_TOKEN=wasimancer-rocks\n</code></pre> <p>In all API requests, include this header:</p> <pre><code>Authorization: Bearer wasimancer-rocks\n</code></pre>"},{"location":"plugins-rest-api-guide/#api-endpoints","title":"API Endpoints","text":""},{"location":"plugins-rest-api-guide/#1-upload-a-new-plugin","title":"1. Upload a New Plugin","text":"<p>Upload a new WebAssembly plugin and register it with the server.</p> <p>Endpoint: <code>POST /upload-plugin</code></p> <p>Headers: - <code>Authorization: Bearer &lt;token&gt;</code> - Authentication token - <code>Content-Type: multipart/form-data</code> - Required for file upload</p> <p>Request Body: - <code>wasmFile</code> - The WebAssembly module file (.wasm) - <code>pluginData</code> - JSON string containing metadata about the plugin</p> <p>Plugin Data Format: <pre><code>{\n  \"name\": \"character-name-generator\",\n  \"path\": \"./bucket/character-name-generator.wasm\",\n  \"version\": \"1.0.0\",\n  \"description\": \"a character name generator\",\n  \"functions\": [\n    {\n      \"displayName\": \"GenerateCharacterName\",\n      \"function\": \"GenerateCharacterName\",\n      \"arguments\": [],\n      \"description\": \"a function to generate a character name\"\n    }\n  ]\n}\n</code></pre></p> <p>Optional Parameters: - <code>dir</code> - Query parameter to specify a custom target directory</p> <p>Success Response: - Status Code: 200 - Body:   <pre><code>{\n  \"message\": \"\ud83c\udf89 File uploaded successfully\",\n  \"filePath\": \"./bucket/character-name-generator.wasm\",\n  \"metadata\": { ... } // The plugin data you provided\n}\n</code></pre></p> <p>Error Responses: - Status Code: 400 - Missing or invalid file/data - Status Code: 403 - Invalid authentication token - Status Code: 500 - Server error</p> <p>cURL Example:</p> <pre><code>#!/bin/bash\nTOKEN=\"wasimancer-rocks\"\n\nUPLOAD_ENDPOINT=\"http://localhost:3001/upload-plugin\"\nWASM_FILE=\"./character-name-generator.wasm\"\n\nread -r -d '' DATA &lt;&lt;- EOM\n{\n  \"name\": \"character-name-generator\",\n  \"path\": \"./bucket/character-name-generator.wasm\",\n  \"version\": \"1.0.0\",\n  \"description\": \"a character name generator\",\n  \"functions\": [\n    {\n      \"displayName\": \"GenerateCharacterName\",\n      \"function\": \"GenerateCharacterName\",\n      \"arguments\": [],\n      \"description\": \"a function to generate a character name\"\n    }\n  ]\n}\nEOM\n\ncurl -X POST ${UPLOAD_ENDPOINT} \\\n  -H \"Authorization: Bearer ${TOKEN}\" \\\n  -F \"wasmFile=@${WASM_FILE}\" \\\n  -F \"pluginData=${DATA}\"\n</code></pre>"},{"location":"plugins-rest-api-guide/#2-update-an-existing-plugin","title":"2. Update an Existing Plugin","text":"<p>Replace an existing plugin with a new implementation while preserving its registration.</p> <p>Endpoint: <code>PUT /update-plugin</code></p> <p>Headers: - <code>Authorization: Bearer &lt;token&gt;</code> - Authentication token - <code>Content-Type: multipart/form-data</code> - Required for file upload</p> <p>Request Body: - <code>wasmFile</code> - The new WebAssembly module file (.wasm) - <code>pluginData</code> - JSON string containing metadata about the plugin (must include the same name as the plugin being updated)</p> <p>Plugin Data Format: Same as for uploading a new plugin</p> <p>Optional Parameters: - <code>dir</code> - Query parameter to specify a custom target directory</p> <p>Success Response: - Status Code: 200 - Body:   <pre><code>{\n  \"message\": \"\ud83c\udf89 File uploaded successfully\",\n  \"filePath\": \"./bucket/character-name-generator.wasm\",\n  \"metadata\": { ... } // The plugin data you provided\n}\n</code></pre></p> <p>Error Responses: - Status Code: 400 - Missing or invalid file/data - Status Code: 403 - Invalid authentication token - Status Code: 500 - Server error</p> <p>cURL Example:</p> <pre><code>#!/bin/bash\nTOKEN=\"wasimancer-rocks\"\n\nUPDATE_ENDPOINT=\"http://localhost:3001/update-plugin\"\nWASM_FILE=\"./character-name-generator.wasm\"\n\nread -r -d '' DATA &lt;&lt;- EOM\n{\n  \"name\": \"character-name-generator\",\n  \"path\": \"./bucket/character-name-generator.wasm\",\n  \"version\": \"1.0.1\",\n  \"description\": \"an updated character name generator\",\n  \"functions\": [\n    {\n      \"displayName\": \"GenerateCharacterName\",\n      \"function\": \"GenerateCharacterName\",\n      \"arguments\": [],\n      \"description\": \"a function to generate an improved character name\"\n    }\n  ]\n}\nEOM\n\ncurl -X PUT ${UPDATE_ENDPOINT} \\\n  -H \"Authorization: Bearer ${TOKEN}\" \\\n  -F \"wasmFile=@${WASM_FILE}\" \\\n  -F \"pluginData=${DATA}\"\n</code></pre>"},{"location":"plugins-rest-api-guide/#3-remove-a-plugin","title":"3. Remove a Plugin","text":"<p>Unregister and delete a plugin from the server.</p> <p>Endpoint: <code>DELETE /remove-plugin/:name</code></p> <p>URL Parameters: - <code>:name</code> - The name of the plugin to remove</p> <p>Headers: - <code>Authorization: Bearer &lt;token&gt;</code> - Authentication token</p> <p>Success Response: - Status Code: 200 - Body:   <pre><code>{\n  \"message\": \"\ud83d\ude42 Plugin removed successfully\"\n}\n</code></pre></p> <p>Error Responses: - Status Code: 400 - Missing plugin name - Status Code: 403 - Invalid authentication token - Status Code: 500 - Server error or plugin not found</p> <p>cURL Example:</p> <pre><code>#!/bin/bash\nTOKEN=\"wasimancer-rocks\"\n\nREMOVE_ENDPOINT=\"http://localhost:3001/remove-plugin\"\nPLUGIN_NAME=\"character-name-generator\"\n\ncurl -X DELETE ${REMOVE_ENDPOINT}/${PLUGIN_NAME} \\\n  -H \"Authorization: Bearer ${TOKEN}\"\n</code></pre>"},{"location":"plugins-rest-api-guide/#practical-examples","title":"Practical Examples","text":""},{"location":"plugins-rest-api-guide/#example-1-creating-and-publishing-a-new-plugin","title":"Example 1: Creating and Publishing a New Plugin","text":"<p>This example shows how to create a simple Go plugin, compile it, and publish it to WASImancer:</p> <pre><code>#!/bin/bash\n# Step 1: Create a directory for your plugin\nmkdir -p roll-dice\ncd roll-dice\n\n# Step 2: Create go.mod file\ncat &gt; go.mod &lt;&lt; 'EOF'\nmodule wasimancer-plugin-roll-dice\ngo 1.23.0\nrequire github.com/extism/go-pdk v1.1.1\nEOF\n\n# Step 3: Create main.go file\ncat &gt; main.go &lt;&lt; 'EOF'\npackage main\n\nimport (\n    \"encoding/json\"\n    \"math/rand\"\n    \"strconv\"\n    \"github.com/extism/go-pdk\"\n)\n\ntype Arguments struct {\n    NumFaces int `json:\"numFaces\"`\n    NumDice  int `json:\"numDice\"`\n}\n\n//export rollDice\nfunc rollDice() {\n    arguments := pdk.InputString()\n    var args Arguments\n    json.Unmarshal([]byte(arguments), &amp;args)\n    numFaces := args.NumFaces \n    numDice := args.NumDice\n\n    sum := 0\n    for i := 0; i &lt; numDice; i++ {\n        dieValue := rand.Intn(numFaces) + 1\n        sum += dieValue\n    }\n\n    pdk.OutputString(strconv.Itoa(sum))\n}\n\nfunc main() {}\nEOF\n\n# Step 4: Compile the plugin\ndocker run --rm -v \"$PWD\":/roll-dice -w /roll-dice k33g/wasm-builder:0.0.7 \\\n  tinygo build -scheduler=none --no-debug \\\n    -o wasimancer-plugin-roll-dice.wasm \\\n    -target wasi main.go\n\n# Step 5: Create publish script\ncat &gt; publish.sh &lt;&lt; 'EOF'\n#!/bin/bash\nTOKEN=\"wasimancer-rocks\"\nUPLOAD_ENDPOINT=\"http://localhost:3001/upload-plugin\"\nWASM_FILE=\"./wasimancer-plugin-roll-dice.wasm\"\n\nread -r -d '' DATA &lt;&lt;- EOM\n{\n  \"name\": \"roll-dice\",\n  \"path\": \"./bucket/wasimancer-plugin-roll-dice.wasm\",\n  \"version\": \"1.0.0\",\n  \"description\": \"roll dice\",\n  \"functions\": [\n    {\n      \"displayName\": \"rollDice\",\n      \"function\": \"rollDice\",\n      \"arguments\": [\n        {\n          \"name\": \"numFaces\",\n          \"type\": \"number\",\n          \"description\": \"number of faces on the dice\"\n        },\n        {\n          \"name\": \"numDice\",\n          \"type\": \"number\",\n          \"description\": \"number of dice to roll\"\n        }\n      ],\n      \"description\": \"a function to roll dice\"\n    }\n  ]\n}\nEOM\n\ncurl -X POST ${UPLOAD_ENDPOINT} \\\n  -H \"Authorization: Bearer ${TOKEN}\" \\\n  -F \"wasmFile=@${WASM_FILE}\" \\\n  -F \"pluginData=${DATA}\"\nEOF\n\n# Step 6: Make the script executable and run it\nchmod +x publish.sh\n./publish.sh\n</code></pre>"},{"location":"plugins-rest-api-guide/#example-2-updating-an-existing-plugin","title":"Example 2: Updating an Existing Plugin","text":"<p>This example shows how to update the roll dice plugin with improved functionality:</p> <pre><code>#!/bin/bash\n# Step 1: Update the main.go file\ncat &gt; main.go &lt;&lt; 'EOF'\npackage main\n\nimport (\n    \"encoding/json\"\n    \"math/rand\"\n    \"time\"\n    \"github.com/extism/go-pdk\"\n)\n\ntype Arguments struct {\n    NumFaces int `json:\"numFaces\"`\n    NumDice  int `json:\"numDice\"`\n}\n\ntype Result struct {\n    Total  int   `json:\"total\"`\n    Values []int `json:\"values\"`\n}\n\n//export rollDice\nfunc rollDice() {\n    // Initialize random with time seed\n    rand.Seed(time.Now().UnixNano())\n\n    // Get input arguments\n    arguments := pdk.InputString()\n    var args Arguments\n    json.Unmarshal([]byte(arguments), &amp;args)\n\n    // Roll dice and track individual values\n    values := make([]int, args.NumDice)\n    total := 0\n\n    for i := 0; i &lt; args.NumDice; i++ {\n        values[i] = rand.Intn(args.NumFaces) + 1\n        total += values[i]\n    }\n\n    // Create and return result\n    result := Result{\n        Total:  total,\n        Values: values,\n    }\n\n    jsonResult, _ := json.Marshal(result)\n    pdk.OutputString(string(jsonResult))\n}\n\nfunc main() {}\nEOF\n\n# Step 2: Recompile the plugin\ndocker run --rm -v \"$PWD\":/roll-dice -w /roll-dice k33g/wasm-builder:0.0.7 \\\n  tinygo build -scheduler=none --no-debug \\\n    -o wasimancer-plugin-roll-dice.wasm \\\n    -target wasi main.go\n\n# Step 3: Create update script\ncat &gt; update.sh &lt;&lt; 'EOF'\n#!/bin/bash\nTOKEN=\"wasimancer-rocks\"\nUPDATE_ENDPOINT=\"http://localhost:3001/update-plugin\"\nWASM_FILE=\"./wasimancer-plugin-roll-dice.wasm\"\n\nread -r -d '' DATA &lt;&lt;- EOM\n{\n  \"name\": \"roll-dice\",\n  \"path\": \"./bucket/wasimancer-plugin-roll-dice.wasm\",\n  \"version\": \"1.1.0\",\n  \"description\": \"enhanced dice rolling with detailed results\",\n  \"functions\": [\n    {\n      \"displayName\": \"rollDice\",\n      \"function\": \"rollDice\",\n      \"arguments\": [\n        {\n          \"name\": \"numFaces\",\n          \"type\": \"number\",\n          \"description\": \"number of faces on the dice\"\n        },\n        {\n          \"name\": \"numDice\",\n          \"type\": \"number\",\n          \"description\": \"number of dice to roll\"\n        }\n      ],\n      \"description\": \"a function to roll dice and get detailed results\"\n    }\n  ]\n}\nEOM\n\ncurl -X PUT ${UPDATE_ENDPOINT} \\\n  -H \"Authorization: Bearer ${TOKEN}\" \\\n  -F \"wasmFile=@${WASM_FILE}\" \\\n  -F \"pluginData=${DATA}\"\nEOF\n\n# Step 4: Make the script executable and run it\nchmod +x update.sh\n./update.sh\n</code></pre>"},{"location":"plugins-rest-api-guide/#example-3-removing-a-plugin","title":"Example 3: Removing a Plugin","text":"<p>This example shows how to remove the roll dice plugin:</p> <pre><code>#!/bin/bash\nTOKEN=\"wasimancer-rocks\"\nREMOVE_ENDPOINT=\"http://localhost:3001/remove-plugin\"\nPLUGIN_NAME=\"roll-dice\"\n\ncurl -X DELETE ${REMOVE_ENDPOINT}/${PLUGIN_NAME} \\\n  -H \"Authorization: Bearer ${TOKEN}\"\n</code></pre>"},{"location":"plugins-rest-api-guide/#best-practices","title":"Best Practices","text":""},{"location":"plugins-rest-api-guide/#versioning","title":"Versioning","text":"<p>Always increment your plugin version when updating:</p> <pre><code>{\n  \"name\": \"example-plugin\",\n  \"version\": \"1.0.1\",  // Increment this with each update\n  \"path\": \"./bucket/example-plugin.wasm\",\n  \"description\": \"An example plugin\"\n}\n</code></pre>"},{"location":"plugins-rest-api-guide/#plugin-naming","title":"Plugin Naming","text":"<p>Use consistent naming conventions: - Plugin names should be kebab-case (e.g., <code>character-name-generator</code>) - Function display names should be descriptive but concise</p>"},{"location":"plugins-rest-api-guide/#validation","title":"Validation","text":"<p>Always validate plugin functionality before deployment: 1. Test the WebAssembly module locally using the Extism CLI 2. Verify input and output formats match your expectations 3. Check for proper error handling</p>"},{"location":"plugins-rest-api-guide/#authorization","title":"Authorization","text":"<p>Keep your authorization token secure: - Use a strong, unique token for each environment - Store tokens in secure environment variables - Rotate tokens periodically</p>"},{"location":"plugins-rest-api-guide/#error-handling","title":"Error Handling","text":"<p>Check for and handle API errors in your deployment scripts:</p> <pre><code>response=$(curl -s -w \"\\n%{http_code}\" -X POST ${UPLOAD_ENDPOINT} \\\n  -H \"Authorization: Bearer ${TOKEN}\" \\\n  -F \"wasmFile=@${WASM_FILE}\" \\\n  -F \"pluginData=${DATA}\")\n\nhttp_code=$(echo \"$response\" | tail -n1)\nresponse_body=$(echo \"$response\" | sed '$d')\n\nif [ \"$http_code\" -ne 200 ]; then\n  echo \"Error: $response_body\"\n  exit 1\nfi\n\necho \"Success: $response_body\"\n</code></pre>"},{"location":"plugins-rest-api-guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"plugins-rest-api-guide/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Invalid Token Error (403): Verify that your <code>WASIMANCER_ADMIN_TOKEN</code> environment variable matches the token in your request.</p> </li> <li> <p>Plugin Not Found (500): When updating or removing, check that the plugin name in your request matches exactly with the registered plugin.</p> </li> <li> <p>File Upload Failed (500): Ensure that the WebAssembly file exists and is accessible.</p> </li> <li> <p>Failed to Load Plugin (500): Verify that your WebAssembly module is correctly compiled and exports the functions referenced in your plugin data.</p> </li> </ol>"},{"location":"plugins-rest-api-guide/#debugging","title":"Debugging","text":"<ol> <li> <p>Check Server Logs: WASImancer logs detailed information about plugin operations.</p> </li> <li> <p>Inspect Plugin Registry: Use the MCP Inspector to list all registered tools and verify your changes.</p> </li> <li> <p>Test Plugin Independently: Use the Extism CLI to test your WebAssembly module before uploading.</p> </li> </ol>"},{"location":"plugins-rest-api-guide/#automation-and-cicd-integration","title":"Automation and CI/CD Integration","text":"<p>You can integrate plugin management into your CI/CD pipeline:</p> <pre><code># Example GitHub Actions workflow\nname: Deploy Plugin\n\non:\n  push:\n    branches: [ main ]\n    paths:\n      - 'plugins/**'\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Build Plugin\n        run: |\n          cd plugins/my-plugin\n          tinygo build -scheduler=none --no-debug -o my-plugin.wasm -target wasi main.go\n\n      - name: Deploy Plugin\n        run: |\n          cd plugins/my-plugin\n          ./publish.sh\n        env:\n          WASIMANCER_TOKEN: ${{ secrets.WASIMANCER_TOKEN }}\n          WASIMANCER_URL: ${{ secrets.WASIMANCER_URL }}\n</code></pre>"},{"location":"plugins-rest-api-guide/#conclusion","title":"Conclusion","text":"<p>WASImancer's Plugin Management API provides a flexible way to dynamically extend your MCP server's capabilities without service interruption. By leveraging this API, you can implement continuous deployment of new tools and features to enhance your AI applications.</p> <p>The combination of WebAssembly's portability and security with WASImancer's dynamic loading capabilities creates a powerful platform for developing and deploying AI tools in production environments.</p>"},{"location":"prompts-guide/","title":"Understanding Prompts in WASImancer","text":"<p>\ud83d\udea7 work in progress</p>"},{"location":"prompts-guide/#what-are-prompts-in-wasimancer","title":"What are Prompts in WASImancer?","text":"<p>Prompts in WASImancer are predefined templates that define how AI models should interact with users or tools. They serve as reusable interaction patterns with customizable variables, allowing for consistent and structured communications between AI applications and the MCP server.</p> <p>Think of prompts as parameterized scripts where:</p> <ul> <li>The structure and wording remain consistent</li> <li>Variables can be substituted dynamically</li> <li>The resulting messages can be used in AI model interactions</li> </ul>"},{"location":"prompts-guide/#the-value-of-prompts","title":"The Value of Prompts","text":"<p>Prompts solve several important challenges in AI application development:</p> <ol> <li>Consistency: Ensure uniform interaction patterns across sessions</li> <li>Reusability: Define templates once and reuse them with different parameters</li> <li>Maintainability: Update prompt templates in one place rather than throughout code</li> <li>Structured Interactions: Provide clear guidance to AI models</li> <li>Separation of Concerns: Keep template definition separate from application logic</li> </ol>"},{"location":"prompts-guide/#prompt-configuration","title":"Prompt Configuration","text":"<p>Prompts in WASImancer are defined in the <code>prompts.yml</code> file, which organizes them into categories and defines their structure.</p>"},{"location":"prompts-guide/#basic-structure","title":"Basic Structure","text":"<p>The basic structure of the <code>prompts.yml</code> file is:</p> <pre><code>prompts:\n  predefined:\n    - name: prompt-name\n      arguments:\n        - name: arg1\n          type: string\n        - name: arg2\n          type: string\n      messages:\n        - text: Message with ${arg1} and ${arg2}\n          role: user\n        - text: Another message in the conversation\n          role: assistant\n</code></pre>"},{"location":"prompts-guide/#key-components","title":"Key Components","text":"<ol> <li>Name: A unique identifier for the prompt</li> <li>Arguments: Variable parameters that can be substituted in the template</li> <li>Each argument has a name and type (currently string)</li> <li>Messages: An array of message templates</li> <li>Each message has text content with variable placeholders</li> <li>Each message has a role (typically \"user\" or \"assistant\")</li> </ol>"},{"location":"prompts-guide/#example-prompts","title":"Example Prompts","text":""},{"location":"prompts-guide/#simple-greeting","title":"Simple Greeting","text":"<pre><code>prompts:\n  predefined:\n    - name: greet-user\n      arguments:\n        - name: nickName\n          type: string\n      messages:\n        - text: Say hello to ${nickName}!\n          role: user\n</code></pre>"},{"location":"prompts-guide/#code-analysis","title":"Code Analysis","text":"<pre><code>prompts:\n  predefined:\n    - name: code-analyst\n      arguments:\n        - name: botName\n          type: string\n        - name: code\n          type: string\n      messages:\n        - text: My name is ${botName}. I am an expert in analyzing code.\n          role: assistant\n        - text: Analyze my source code: ${code}\n          role: user\n</code></pre>"},{"location":"prompts-guide/#tool-interaction","title":"Tool Interaction","text":"<pre><code>prompts:\n  predefined:\n    - name: roll-dice\n      arguments:\n        - name: numFaces\n          type: string\n        - name: numDice\n          type: string\n      messages:\n        - text: \ud83c\udfb2 Rolling ${numDice} dice(s) with ${numFaces} faces...\n          role: user\n</code></pre>"},{"location":"prompts-guide/#how-prompts-work-in-wasimancer","title":"How Prompts Work in WASImancer","text":"<p>When WASImancer starts, it reads the <code>prompts.yml</code> file and registers all defined prompts with the MCP server. The server then processes these templates when clients request them with specific argument values.</p>"},{"location":"prompts-guide/#prompt-registration","title":"Prompt Registration","text":"<p>Inside WASImancer, prompts are registered using code similar to:</p> <pre><code>server.prompt(\n  prompt.name,\n  schemaObj,  // Zod schema built from argument definitions\n  (args) =&gt; ({\n    messages: prompt.messages.map(message =&gt; {\n      // Replace template variables in the text\n      let text = message.text;\n      prompt.arguments.forEach(arg =&gt; {\n        const regex = new RegExp(`\\\\$\\\\{${arg.name}\\\\}`, 'g');\n        text = text.replace(regex, args[arg.name]);\n      });\n\n      return {\n        role: message.role,\n        content: {\n          type: \"text\",\n          text: text\n        }\n      };\n    })\n  })\n);\n</code></pre> <p>This registration process: 1. Registers the prompt name 2. Creates a validation schema for arguments 3. Defines a function that substitutes arguments into the template</p>"},{"location":"prompts-guide/#variable-substitution","title":"Variable Substitution","text":"<p>The core functionality of prompts is variable substitution, where placeholders in the form <code>${variableName}</code> are replaced with actual values provided by the client.</p> <p>For example, if a prompt template contains: <pre><code>Hello, ${name}! Welcome to ${service}.\n</code></pre></p> <p>And a client provides: <pre><code>{\n  \"name\": \"Alice\",\n  \"service\": \"WASImancer\"\n}\n</code></pre></p> <p>The resulting text would be: <pre><code>Hello, Alice! Welcome to WASImancer.\n</code></pre></p>"},{"location":"prompts-guide/#using-prompts-with-mcp-clients","title":"Using Prompts with MCP Clients","text":""},{"location":"prompts-guide/#listing-available-prompts","title":"Listing Available Prompts","text":"<p>In a JavaScript MCP client, you can list available prompts:</p> <pre><code>const prompts = await mcpClient.listPrompts();\nconsole.log(\"\ud83d\udcdc Available Prompts:\", prompts);\n</code></pre> <p>This will return information about all registered prompts, including their names and required arguments.</p>"},{"location":"prompts-guide/#getting-a-specific-prompt","title":"Getting a Specific Prompt","text":"<p>To retrieve a specific prompt with arguments:</p> <pre><code>const prompt = await mcpClient.getPrompt({\n  name: \"roll-dice\",\n  arguments: { numDice: \"3\", numFaces: \"12\" }, // Always use strings for arguments\n});\n\nlet userInstructions = prompt.messages[0].content.text;\nconsole.log(\"\ud83d\udcdd User Instructions:\", userInstructions);\n// Output: \"\ud83c\udfb2 Rolling 3 dice(s) with 12 faces...\"\n</code></pre>"},{"location":"prompts-guide/#example-using-a-prompt-with-an-llm","title":"Example: Using a Prompt with an LLM","text":"<pre><code>// Fetch a prompt with arguments\nconst prompt = await mcpClient.getPrompt({\n  name: \"code-analyst\",\n  arguments: { \n    botName: \"CodeWizard\",\n    code: \"function add(a, b) { return a + b; }\"\n  },\n});\n\n// Extract messages\nconst messages = prompt.messages.map(msg =&gt; [\n  msg.role,\n  msg.content.text\n]);\n\n// Use in LLM conversation\nconst llmOutput = await llm.invoke(messages);\n</code></pre>"},{"location":"prompts-guide/#best-practices-for-prompts","title":"Best Practices for Prompts","text":""},{"location":"prompts-guide/#designing-effective-prompts","title":"Designing Effective Prompts","text":"<ol> <li>Be Clear and Specific: Prompts should provide clear instructions</li> <li>Use Appropriate Context: Include relevant context in the prompt</li> <li>Maintain Consistency: Use consistent language and structure</li> <li>Consider Roles: Use \"user\" and \"assistant\" roles appropriately</li> </ol>"},{"location":"prompts-guide/#technical-implementation","title":"Technical Implementation","text":"<ol> <li>Keep Arguments Simple: Limit the number and complexity of arguments</li> <li>Validate Input: Ensure client-provided values are appropriate</li> <li>Handle Missing Values: Provide defaults for optional arguments</li> <li>Escape Special Characters: Be careful with characters that might be interpreted specially</li> </ol>"},{"location":"prompts-guide/#organization","title":"Organization","text":"<ol> <li>Group Related Prompts: Organize prompts by functionality</li> <li>Use Descriptive Names: Choose names that clearly indicate purpose</li> <li>Document Expected Behavior: Include comments explaining prompt usage</li> </ol>"},{"location":"prompts-guide/#use-cases-for-prompts","title":"Use Cases for Prompts","text":""},{"location":"prompts-guide/#ai-conversation-starters","title":"AI Conversation Starters","text":"<pre><code>- name: creative-writing-coach\n  arguments:\n    - name: genre\n      type: string\n    - name: topic\n      type: string\n  messages:\n    - text: I am a writing coach specializing in ${genre} fiction. Let's develop a story about ${topic}.\n      role: assistant\n</code></pre>"},{"location":"prompts-guide/#tool-invocation-patterns","title":"Tool Invocation Patterns","text":"<pre><code>- name: search-request\n  arguments:\n    - name: query\n      type: string\n    - name: maxResults\n      type: string\n  messages:\n    - text: Please search for information about \"${query}\" and return up to ${maxResults} results.\n      role: user\n</code></pre>"},{"location":"prompts-guide/#multilingual-support","title":"Multilingual Support","text":"<pre><code>- name: translate-greeting\n  arguments:\n    - name: language\n      type: string\n    - name: userName\n      type: string\n  messages:\n    - text: Translate \"Hello, ${userName}! How are you today?\" into ${language}.\n      role: user\n</code></pre>"},{"location":"prompts-guide/#format-standardization","title":"Format Standardization","text":"<pre><code>- name: product-description\n  arguments:\n    - name: productName\n      type: string\n    - name: category\n      type: string\n    - name: price\n      type: string\n    - name: features\n      type: string\n  messages:\n    - text: \"Create a product description for ${productName} in the ${category} category. It costs ${price} and has these features: ${features}\"\n      role: user\n</code></pre>"},{"location":"prompts-guide/#advanced-prompt-techniques","title":"Advanced Prompt Techniques","text":""},{"location":"prompts-guide/#message-sequences","title":"Message Sequences","text":"<p>Prompts can include multiple messages to create a conversation flow:</p> <pre><code>- name: interview-simulation\n  arguments:\n    - name: position\n      type: string\n    - name: candidateName\n      type: string\n  messages:\n    - text: I am an interviewer for a ${position} position. I'll be conducting your interview today.\n      role: assistant\n    - text: Hello, my name is ${candidateName} and I'm applying for the ${position} role.\n      role: user\n    - text: Great to meet you, ${candidateName}. Can you tell me about your experience with this type of work?\n      role: assistant\n</code></pre>"},{"location":"prompts-guide/#combining-with-resources","title":"Combining with Resources","text":"<p>Prompts can be particularly powerful when combined with resources:</p> <pre><code>// Fetch system instructions from resources\nconst llmInstructions = await mcpClient.readResource({\n  uri: \"llm://instructions\",\n});\nlet systemInstructions = llmInstructions.contents[0].text;\n\n// Fetch a specific prompt with arguments\nconst prompt = await mcpClient.getPrompt({\n  name: \"technical-question\",\n  arguments: { topic: \"WebAssembly\" },\n});\n\n// Combine in a conversation\nlet messages = [\n  [\"system\", systemInstructions],\n  [prompt.messages[0].role, prompt.messages[0].content.text],\n];\n</code></pre>"},{"location":"prompts-guide/#future-directions","title":"Future Directions","text":"<p>Future versions of WASImancer may extend prompts with:</p> <ol> <li>More Complex Variables: Support for structured data in arguments</li> <li>Conditional Logic: Include or exclude sections based on conditions</li> <li>Markup Support: Allow HTML or Markdown formatting in prompts</li> <li>Localization: Built-in support for multiple languages</li> <li>Prompt Chaining: Create sequences of prompts that build on each other</li> </ol>"},{"location":"prompts-guide/#conclusion","title":"Conclusion","text":"<p>Prompts in WASImancer provide a powerful way to create consistent, reusable templates for AI interactions. By properly configuring and utilizing prompts, you can enhance your AI applications with structured communication patterns that improve consistency and reduce development time.</p> <p>Whether you're building AI assistants, tool-augmented language models, or complex conversational systems, WASImancer's prompt system provides the flexibility and structure needed to create effective AI interactions.</p>"},{"location":"prompts-rest-api-guide/","title":"WASImancer Prompt Management API Guide","text":"<p>\ud83d\udea7 work in progress</p> <p>This guide explains how to use WASImancer's REST API to dynamically add, update, and remove prompts without restarting the server.</p>"},{"location":"prompts-rest-api-guide/#overview","title":"Overview","text":"<p>WASImancer provides a REST API that enables:</p> <ul> <li>Publishing new prompts - Add template-based prompts with variable substitution</li> <li>Updating existing prompts - Modify a prompt's structure, arguments, and templates</li> <li>Removing prompts - Delete prompts that are no longer needed</li> </ul> <p>These operations allow you to manage your MCP server's prompts at runtime without service interruption.</p>"},{"location":"prompts-rest-api-guide/#administration-authentication","title":"Administration authentication","text":"<p>All Administration API endpoints require authentication using a Bearer token. This token is configured when starting the WASImancer server using the <code>WASIMANCER_ADMIN_TOKEN</code> environment variable:</p> <pre><code>environment:\n  - WASIMANCER_ADMIN_TOKEN=wasimancer-rocks\n</code></pre> <p>In all API requests, include this header:</p> <pre><code>Authorization: Bearer wasimancer-rocks\n</code></pre>"},{"location":"prompts-rest-api-guide/#api-endpoints","title":"API Endpoints","text":""},{"location":"prompts-rest-api-guide/#1-add-a-new-prompt","title":"1. Add a New Prompt","text":"<p>Add a new prompt template to the server.</p> <p>Endpoint: <code>POST /add-prompt</code></p> <p>Headers: - <code>Authorization: Bearer &lt;token&gt;</code> - Authentication token - <code>Content-Type: application/json</code> - Content type for the request body</p> <p>Request Body: <pre><code>{\n  \"name\": \"character-greeting\",\n  \"arguments\": [\n    {\n      \"name\": \"character\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"emotion\",\n      \"type\": \"string\"\n    }\n  ],\n  \"messages\": [\n    {\n      \"text\": \"Greet the user as \\${character} feeling \\${emotion}\",\n      \"role\": \"user\"\n    }\n  ]\n}\n</code></pre></p> <p>Success Response: - Status Code: 200 - Body:   <pre><code>{\n  \"message\": \"\ud83c\udf89 Prompt character-greeting added successfully\",\n  \"prompt\": { ... } // The prompt data you provided\n}\n</code></pre></p> <p>Error Responses: - Status Code: 400 - Missing or invalid prompt data - Status Code: 403 - Invalid authentication token - Status Code: 500 - Server error</p> <p>cURL Example:</p> <pre><code>#!/bin/bash\nTOKEN=\"wasimancer-rocks\"\n\nADD_ENDPOINT=\"http://localhost:3001/add-prompt\"\n\nread -r -d '' DATA &lt;&lt;- EOM\n{\n  \"name\": \"character-greeting\",\n  \"arguments\": [\n    {\n      \"name\": \"character\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"emotion\",\n      \"type\": \"string\"\n    }\n  ],\n  \"messages\": [\n    {\n      \"text\": \"Greet the user as \\${character} feeling \\${emotion}\",\n      \"role\": \"user\"\n    }\n  ]\n}\nEOM\n\ncurl -X POST ${ADD_ENDPOINT} \\\n  -H \"Authorization: Bearer ${TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d \"${DATA}\"\n</code></pre>"},{"location":"prompts-rest-api-guide/#2-update-an-existing-prompt","title":"2. Update an Existing Prompt","text":"<p>Update an existing prompt's definition, arguments, or messages.</p> <p>Endpoint: <code>PUT /update-prompt/:name</code></p> <p>URL Parameters: - <code>:name</code> - The name of the prompt to update</p> <p>Headers: - <code>Authorization: Bearer &lt;token&gt;</code> - Authentication token - <code>Content-Type: application/json</code> - Content type</p> <p>Request Body: Same format as for adding a prompt, but must include the same name as in the URL.</p> <p>Success Response: - Status Code: 200 - Body:   <pre><code>{\n  \"message\": \"\ud83c\udf89 Prompt character-greeting updated successfully\",\n  \"prompt\": { ... } // The updated prompt data\n}\n</code></pre></p> <p>Error Responses: - Status Code: 400 - Missing or invalid prompt data - Status Code: 403 - Invalid authentication token - Status Code: 404 - Prompt not found - Status Code: 500 - Server error</p> <p>cURL Example:</p> <pre><code>#!/bin/bash\nTOKEN=\"wasimancer-rocks\"\nPROMPT_NAME=\"character-greeting\"\n\nUPDATE_ENDPOINT=\"http://localhost:3001/update-prompt/${PROMPT_NAME}\"\n\nread -r -d '' DATA &lt;&lt;- EOM\n{\n  \"name\": \"character-greeting\",\n  \"arguments\": [\n    {\n      \"name\": \"character\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"emotion\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"setting\",\n      \"type\": \"string\"\n    }\n  ],\n  \"messages\": [\n    {\n      \"text\": \"Greet the user as \\${character} feeling \\${emotion} in a \\${setting} setting\",\n      \"role\": \"user\"\n    }\n  ]\n}\nEOM\n\ncurl -X PUT ${UPDATE_ENDPOINT} \\\n  -H \"Authorization: Bearer ${TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d \"${DATA}\"\n</code></pre>"},{"location":"prompts-rest-api-guide/#3-remove-a-prompt","title":"3. Remove a Prompt","text":"<p>Remove a prompt from the server.</p> <p>Endpoint: <code>DELETE /remove-prompt/:name</code></p> <p>URL Parameters: - <code>:name</code> - The name of the prompt to remove</p> <p>Headers: - <code>Authorization: Bearer &lt;token&gt;</code> - Authentication token</p> <p>Success Response: - Status Code: 200 - Body:   <pre><code>{\n  \"message\": \"\ud83d\ude42 Prompt character-greeting removed successfully\"\n}\n</code></pre></p> <p>Error Responses: - Status Code: 400 - Missing prompt name - Status Code: 403 - Invalid authentication token - Status Code: 404 - Prompt not found - Status Code: 500 - Server error</p> <p>cURL Example:</p> <pre><code>#!/bin/bash\nTOKEN=\"wasimancer-rocks\"\nPROMPT_NAME=\"character-greeting\"\n\nREMOVE_ENDPOINT=\"http://localhost:3001/remove-prompt/${PROMPT_NAME}\"\n\ncurl -X DELETE ${REMOVE_ENDPOINT} \\\n  -H \"Authorization: Bearer ${TOKEN}\"\n</code></pre>"},{"location":"prompts-rest-api-guide/#understanding-prompts-in-wasimancer","title":"Understanding Prompts in WASImancer","text":""},{"location":"prompts-rest-api-guide/#prompt-structure","title":"Prompt Structure","text":"<p>A prompt in WASImancer consists of:</p> <ol> <li>Name: A unique identifier for the prompt</li> <li>Arguments: Variables that can be substituted in the template</li> <li>Each argument has a name and type (string, number, boolean)</li> <li>Messages: An array of message templates</li> <li>Each message has text content with variable placeholders</li> <li>Each message has a role (user, assistant, system)</li> </ol>"},{"location":"prompts-rest-api-guide/#variable-substitution","title":"Variable Substitution","text":"<p>The core functionality of prompts is variable substitution, where placeholders in the form <code>${variableName}</code> are replaced with actual values provided by the client.</p> <p>For example, if a prompt template contains: <pre><code>Hello, ${name}! Welcome to ${service}.\n</code></pre></p> <p>And a client provides: <pre><code>{\n  \"name\": \"Alice\",\n  \"service\": \"WASImancer\"\n}\n</code></pre></p> <p>The resulting text would be: <pre><code>Hello, Alice! Welcome to WASImancer.\n</code></pre></p>"},{"location":"prompts-rest-api-guide/#example-prompt-types","title":"Example Prompt Types","text":""},{"location":"prompts-rest-api-guide/#conversation-starters","title":"Conversation Starters","text":"<pre><code>{\n  \"name\": \"creative-writing-coach\",\n  \"arguments\": [\n    {\n      \"name\": \"genre\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"topic\",\n      \"type\": \"string\"\n    }\n  ],\n  \"messages\": [\n    {\n      \"text\": \"I am a writing coach specializing in \\${genre} fiction. Let's develop a story about \\${topic}.\",\n      \"role\": \"assistant\"\n    }\n  ]\n}\n</code></pre>"},{"location":"prompts-rest-api-guide/#multi-message-interaction-templates","title":"Multi-Message Interaction Templates","text":"<pre><code>{\n  \"name\": \"interview-simulation\",\n  \"arguments\": [\n    {\n      \"name\": \"position\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"candidateName\",\n      \"type\": \"string\"\n    }\n  ],\n  \"messages\": [\n    {\n      \"text\": \"I am an interviewer for a \\${position} position. I'll be conducting your interview today.\",\n      \"role\": \"assistant\"\n    },\n    {\n      \"text\": \"Hello, my name is \\${candidateName} and I'm applying for the ${position} role.\",\n      \"role\": \"user\"\n    },\n    {\n      \"text\": \"Great to meet you, \\${candidateName}. Can you tell me about your experience with this type of work?\",\n      \"role\": \"assistant\"\n    }\n  ]\n}\n</code></pre>"},{"location":"prompts-rest-api-guide/#tool-invocation-templates","title":"Tool Invocation Templates","text":"<pre><code>{\n  \"name\": \"search-request\",\n  \"arguments\": [\n    {\n      \"name\": \"query\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"maxResults\",\n      \"type\": \"string\"\n    }\n  ],\n  \"messages\": [\n    {\n      \"text\": \"Please search for information about '\\${query}' and return up to \\${maxResults} results.\",\n      \"role\": \"user\"\n    }\n  ]\n}\n</code></pre>"},{"location":"prompts-rest-api-guide/#practical-applications","title":"Practical Applications","text":""},{"location":"prompts-rest-api-guide/#1-creating-an-interactive-qa-template","title":"1. Creating an Interactive QA Template","text":"<pre><code>#!/bin/bash\nTOKEN=\"wasimancer-rocks\"\n\nADD_ENDPOINT=\"http://localhost:3001/add-prompt\"\n\nread -r -d '' DATA &lt;&lt;- EOM\n{\n  \"name\": \"qa-expert\",\n  \"arguments\": [\n    {\n      \"name\": \"topic\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"expertise_level\",\n      \"type\": \"string\"\n    }\n  ],\n  \"messages\": [\n    {\n      \"text\": \"You are an expert on \\${topic}. Provide answers suitable for someone with \\${expertise_level} knowledge.\",\n      \"role\": \"assistant\"\n    },\n    {\n      \"text\": \"I'd like to learn more about \\${topic}. Can you help me?\",\n      \"role\": \"user\"\n    }\n  ]\n}\nEOM\n\ncurl -X POST ${ADD_ENDPOINT} \\\n  -H \"Authorization: Bearer ${TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d \"${DATA}\"\n</code></pre>"},{"location":"prompts-rest-api-guide/#2-creating-a-tool-augmented-prompt","title":"2. Creating a Tool-Augmented Prompt","text":"<pre><code>#!/bin/bash\nTOKEN=\"wasimancer-rocks\"\n\nADD_ENDPOINT=\"http://localhost:3001/add-prompt\"\n\nread -r -d '' DATA &lt;&lt;- EOM\n{\n  \"name\": \"dice-game-master\",\n  \"arguments\": [\n    {\n      \"name\": \"character_name\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"difficulty\",\n      \"type\": \"string\"\n    }\n  ],\n  \"messages\": [\n    {\n      \"text\": \"You are playing as \\${character_name} in a tabletop RPG. The game master sets a \\${difficulty} challenge. Roll the dice to determine your success.\",\n      \"role\": \"user\"\n    }\n  ]\n}\nEOM\n\ncurl -X POST ${ADD_ENDPOINT} \\\n  -H \"Authorization: Bearer ${TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d \"${DATA}\"\n</code></pre>"},{"location":"prompts-rest-api-guide/#best-practices","title":"Best Practices","text":""},{"location":"prompts-rest-api-guide/#designing-effective-prompts","title":"Designing Effective Prompts","text":"<ol> <li>Be Clear and Specific: Prompts should provide clear instructions</li> <li>Use Appropriate Context: Include relevant context in the prompt</li> <li>Maintain Consistency: Use consistent language and structure</li> <li>Consider Roles: Use \"user\" and \"assistant\" roles appropriately</li> </ol>"},{"location":"prompts-rest-api-guide/#organization","title":"Organization","text":"<ol> <li>Group Related Prompts: Create prompt families for related use cases</li> <li>Use Descriptive Names: Choose names that clearly indicate purpose</li> <li>Document Arguments: Provide clear descriptions for each argument</li> </ol>"},{"location":"prompts-rest-api-guide/#conclusion","title":"Conclusion","text":"<p>WASImancer's Prompt Management API provides a powerful way to dynamically extend your MCP server's capabilities without service interruption. By leveraging this API, you can implement dynamic prompt templates that enhance your AI applications with structured, reusable interaction patterns.</p> <p>The combination of template-based prompts with dynamic management capabilities allows you to create rich, interactive experiences for users while maintaining flexibility and control over your system's behavior.</p>"},{"location":"resources-guide/","title":"Understanding Resources in WASImancer","text":"<p>\ud83d\udea7 work in progress</p>"},{"location":"resources-guide/#what-are-resources-in-wasimancer","title":"What are Resources in WASImancer?","text":"<p>Resources in WASImancer are predefined information elements that can be accessed by MCP clients. They provide a way to store and deliver static data, contextual information, or configuration details that AI models or applications can query and utilize.</p> <p>Resources serve as a central repository of information that can be referenced consistently across different interactions, making them ideal for:</p> <ul> <li>System instructions for large language models</li> <li>Reference information for tools</li> <li>Context data for AI applications</li> <li>Configuration settings for clients</li> </ul>"},{"location":"resources-guide/#resource-configuration","title":"Resource Configuration","text":"<p>Resources in WASImancer are defined in the <code>resources.yml</code> file, which follows a specific structure to organize both static and (in future versions) dynamic resources.</p>"},{"location":"resources-guide/#basic-structure","title":"Basic Structure","text":"<p>The basic structure of the <code>resources.yml</code> file is:</p> <pre><code>resources:\n  static:\n    - name: resource-name\n      uri: scheme://identifier\n      contents:\n        - text: Resource content goes here\n          # Additional key-value pairs can be included\n          key1: value1\n          key2: value2\n        - text: Another content item\n          # Multiple content items can be defined\n\n  dynamic: # Reserved for future use\n    # Dynamic resources will be added in future versions\n</code></pre>"},{"location":"resources-guide/#key-components","title":"Key Components","text":"<ol> <li>Name: A unique identifier for the resource within WASImancer</li> <li>URI: A URI-style identifier that follows the format <code>scheme://identifier</code> </li> <li>Contents: An array of content items, each with at least a <code>text</code> field and optionally additional key-value pairs</li> </ol>"},{"location":"resources-guide/#uri-schemes","title":"URI Schemes","text":"<p>WASImancer supports various URI schemes to identify different types of resources:</p> <ul> <li><code>config://</code>: Configuration settings</li> <li><code>info://</code>: Informational content</li> <li><code>llm://</code>: Large Language Model specific content (like system instructions)</li> <li><code>data://</code>: Data references</li> <li><code>doc://</code>: Documentation</li> </ul> <p>These schemes help organize resources and make their purpose clear to both developers and clients.</p>"},{"location":"resources-guide/#example-resources","title":"Example Resources","text":""},{"location":"resources-guide/#system-instructions-for-llms","title":"System Instructions for LLMs","text":"<pre><code>resources:\n  static:\n    - name: llm-instructions\n      uri: llm://instructions\n      contents:\n        - text: You are a helpful AI assistant. You can help users by providing information and assistance with various tasks.\n</code></pre>"},{"location":"resources-guide/#server-information","title":"Server Information","text":"<pre><code>resources:\n  static:\n    - name: server-info\n      uri: config://server\n      contents:\n        - text: This is WASImancer [0.0.3], running on MCP!\n</code></pre>"},{"location":"resources-guide/#user-profile-information","title":"User Profile Information","text":"<pre><code>resources:\n  static:\n    - name: user-profile\n      uri: info://user\n      contents:\n        - text: User information\n          firstName: John\n          lastName: Doe\n          role: Administrator\n          preferences:\n            theme: dark\n            language: en-US\n</code></pre>"},{"location":"resources-guide/#multiple-content-items","title":"Multiple Content Items","text":"<p>Resources can have multiple content items, each potentially with different attributes:</p> <pre><code>resources:\n  static:\n    - name: documentation\n      uri: doc://api-reference\n      contents:\n        - text: API Overview\n          section: introduction\n          format: markdown\n        - text: Getting Started with the API\n          section: quickstart\n          format: markdown\n        - text: API Endpoints\n          section: reference\n          format: json\n          schema: \"https://example.com/schemas/api.json\"\n</code></pre>"},{"location":"resources-guide/#how-resources-work-in-wasimancer","title":"How Resources Work in WASImancer","text":"<p>When WASImancer starts, it reads the <code>resources.yml</code> file and registers all defined resources with the MCP server. The server then makes these resources available to clients through the MCP protocol.</p>"},{"location":"resources-guide/#resource-registration","title":"Resource Registration","text":"<p>Inside WASImancer, resources are registered using code similar to:</p> <pre><code>server.resource(\n  resource.name,\n  resource.uri,\n  async (uri) =&gt; ({\n    contents: resource.contents.map(content =&gt; ({\n      uri: uri.href,  // Required field\n      ...content      // Spread all other properties from YAML\n    }))\n  })\n);\n</code></pre> <p>This makes each resource accessible via its URI.</p>"},{"location":"resources-guide/#client-access","title":"Client Access","text":"<p>MCP clients can access resources in two steps:</p> <ol> <li>List Resources: Clients can request a list of all available resources</li> <li>Read Resource: Clients can request the contents of a specific resource by URI</li> </ol> <p>This two-step process allows clients to discover available resources and then access those they need.</p>"},{"location":"resources-guide/#using-resources-with-mcp-clients","title":"Using Resources with MCP Clients","text":""},{"location":"resources-guide/#listing-available-resources","title":"Listing Available Resources","text":"<p>In a JavaScript MCP client, you can list available resources:</p> <pre><code>const resources = await mcpClient.listResources();\nconsole.log(\"\ud83d\udcdc Available Resources:\", resources);\n</code></pre> <p>The response will include all resource names and URIs.</p>"},{"location":"resources-guide/#reading-a-specific-resource","title":"Reading a Specific Resource","text":"<p>To read the contents of a specific resource:</p> <pre><code>const llmInstruction = await mcpClient.readResource({\n  uri: \"llm://instructions\",\n});\n\n// Resource Content:\nlet systemInstructions = llmInstruction.contents[0].text;\nconsole.log(\"\ud83d\udcdd System Instructions:\", systemInstructions);\n</code></pre>"},{"location":"resources-guide/#example-using-a-resource-with-an-llm","title":"Example: Using a Resource with an LLM","text":"<pre><code>// Fetch system instructions from resources\nconst llmInstruction = await mcpClient.readResource({\n  uri: \"llm://instructions\",\n});\nlet systemInstructions = llmInstruction.contents[0].text;\n\n// Use in LLM conversation\nconst llmWithTools = llm.bindTools(langchainTools);\nlet messages = [\n  [\"system\", systemInstructions],\n  [\"user\", userQuery],\n];\nvar llmOutput = await llmWithTools.invoke(messages);\n</code></pre>"},{"location":"resources-guide/#best-practices-for-resources","title":"Best Practices for Resources","text":""},{"location":"resources-guide/#organizing-resources","title":"Organizing Resources","text":"<ol> <li>Use Consistent Naming: Follow a clear naming convention for resources</li> <li>Group Related Resources: Use URI schemes to group related resources</li> <li>Keep Content Focused: Each resource should have a specific purpose</li> <li>Use Multiple Content Items: When appropriate, break complex information into multiple content items</li> </ol>"},{"location":"resources-guide/#structure-and-format","title":"Structure and Format","text":"<ol> <li>Include Descriptive Text: Always provide a clear <code>text</code> field for each content item</li> <li>Use Appropriate Metadata: Add relevant key-value pairs to provide context and structure</li> <li>Consider Format Needs: Structure content based on how it will be used by clients</li> </ol>"},{"location":"resources-guide/#security-and-privacy","title":"Security and Privacy","text":"<ol> <li>Avoid Sensitive Data: Do not store sensitive data in resources unless necessary</li> <li>Use Vague References: When referring to internal details, be general rather than specific</li> <li>Consider Validation: Implement validation for resource contents in critical applications</li> </ol>"},{"location":"resources-guide/#use-cases-for-resources","title":"Use Cases for Resources","text":""},{"location":"resources-guide/#ai-system-instructions","title":"AI System Instructions","text":"<p>Resources are ideal for storing system instructions for language models:</p> <pre><code>- name: coding-assistant\n  uri: llm://coding-instructions\n  contents:\n    - text: You are an expert coding assistant. You help users write, understand, and debug code. Focus on providing clear explanations and practical solutions.\n</code></pre>"},{"location":"resources-guide/#configuration-settings","title":"Configuration Settings","text":"<p>Store configuration information that clients may need:</p> <pre><code>- name: api-config\n  uri: config://api\n  contents:\n    - text: API Configuration\n      rateLimit: 100\n      timeoutSeconds: 30\n      version: \"2.0\"\n</code></pre>"},{"location":"resources-guide/#context-data","title":"Context Data","text":"<p>Provide contextual information for specialized tools:</p> <pre><code>- name: weather-context\n  uri: data://weather-service\n  contents:\n    - text: Weather Service Information\n      provider: \"WeatherAPI\"\n      units: \"metric\"\n      defaultLocation: \"San Francisco\"\n</code></pre>"},{"location":"resources-guide/#client-documentation","title":"Client Documentation","text":"<p>Offer reference documentation for client applications:</p> <pre><code>- name: client-docs\n  uri: doc://client\n  contents:\n    - text: The client should first list available tools using the listTools() method, then choose appropriate tools based on user needs.\n</code></pre>"},{"location":"resources-guide/#future-directions-dynamic-resources","title":"Future Directions: Dynamic Resources","text":"<p>While currently WASImancer focuses on static resources, future versions will introduce dynamic resources that can:</p> <ol> <li>Generate Content: Create content on-demand based on parameters</li> <li>Access External Data: Fetch information from databases or APIs</li> <li>Personalize Content: Adapt resource content based on client or user information</li> </ol> <p>This will make resources even more powerful for delivering contextual information to AI applications.</p>"},{"location":"resources-guide/#conclusion","title":"Conclusion","text":"<p>Resources in WASImancer provide a flexible and standardized way to deliver contextual information to MCP clients. By properly configuring and utilizing resources, you can enhance your AI applications with consistent reference information, configuration settings, and contextual data.</p> <p>The structured nature of resources makes them ideal for storing system instructions for large language models, providing reference information for tools, and configuring client applications in a centralized and consistent manner.</p>"},{"location":"resources-rest-api-guide/","title":"WASImancer Resource API Guide","text":"<p>\ud83d\udea7 work in progress</p> <p>This guide explains how to use WASImancer's REST API to dynamically add, update, and remove resources without restarting the server.</p>"},{"location":"resources-rest-api-guide/#overview","title":"Overview","text":"<p>WASImancer provides REST API endpoints that enable:</p> <ul> <li>Adding new resources - Upload static or dynamic resource definitions </li> <li>Updating existing resources - Modify a resource's properties and contents</li> <li>Removing resources - Delete resources that are no longer needed</li> </ul> <p>These operations allow you to manage your MCP server's resources at runtime without service interruption.</p>"},{"location":"resources-rest-api-guide/#administration-authentication","title":"Administration authentication","text":"<p>All Administration API endpoints require authentication using a Bearer token. This token is configured when starting the WASImancer server using the <code>WASIMANCER_ADMIN_TOKEN</code> environment variable:</p> <pre><code>environment:\n  - WASIMANCER_ADMIN_TOKEN=wasimancer-rocks\n</code></pre> <p>In all API requests, include this header:</p> <pre><code>Authorization: Bearer wasimancer-rocks\n</code></pre>"},{"location":"resources-rest-api-guide/#api-endpoints","title":"API Endpoints","text":""},{"location":"resources-rest-api-guide/#1-add-a-new-resource","title":"1. Add a New Resource","text":"<p>Add a new static or dynamic resource to the server.</p> <p>Endpoint: <code>POST /add-resource</code></p> <p>Headers: - <code>Authorization: Bearer &lt;token&gt;</code> - Authentication token - <code>Content-Type: application/json</code> - Content type</p> <p>Request Body (Static Resource): <pre><code>{\n  \"name\": \"example-info\",\n  \"uri\": \"info://example\",\n  \"contents\": [\n    {\n      \"text\": \"This is an example static resource\"\n    },\n    {\n      \"text\": \"Additional information\",\n      \"customField\": \"Custom value\"\n    }\n  ]\n}\n</code></pre></p> <p>Request Body (Dynamic Resource): <pre><code>{\n  \"name\": \"greet-user\",\n  \"uri\": \"greet-user://{firstName}/{lastName}\",\n  \"arguments\": [\n    {\n      \"name\": \"firstName\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"lastName\",\n      \"type\": \"string\"\n    }\n  ],\n  \"contents\": [\n    {\n      \"text\": \"Hello \\${firstName} \\${lastName}, welcome!\"\n    }\n  ]\n}\n</code></pre></p> <p>Success Response: - Status Code: 200 - Body:   <pre><code>{\n  \"message\": \"\ud83c\udf89 Resource example-info added successfully\",\n  \"resource\": { ... } // The resource you provided\n}\n</code></pre></p> <p>Error Responses: - Status Code: 400 - Missing or invalid resource data - Status Code: 403 - Invalid authentication token - Status Code: 500 - Server error</p> <p>cURL Example (Static Resource):</p> <pre><code>#!/bin/bash\nTOKEN=\"wasimancer-rocks\"\n\nADD_ENDPOINT=\"http://localhost:3001/add-resource\"\n\nread -r -d '' DATA &lt;&lt;- EOM\n{\n  \"name\": \"server-info\",\n  \"uri\": \"config://server-details\",\n  \"contents\": [\n    {\n      \"text\": \"Server configuration details\",\n      \"version\": \"1.0.0\",\n      \"environment\": \"production\"\n    }\n  ]\n}\nEOM\n\ncurl -X POST ${ADD_ENDPOINT} \\\n  -H \"Authorization: Bearer ${TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d \"${DATA}\"\n</code></pre> <p>cURL Example (Dynamic Resource):</p> <pre><code>#!/bin/bash\nTOKEN=\"wasimancer-rocks\"\n\nADD_ENDPOINT=\"http://localhost:3001/add-resource\"\n\nread -r -d '' DATA &lt;&lt;- EOM\n{\n  \"name\": \"welcome-message\",\n  \"uri\": \"message://{username}/{language}\",\n  \"arguments\": [\n    {\n      \"name\": \"username\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"language\",\n      \"type\": \"string\"\n    }\n  ],\n  \"contents\": [\n    {\n      \"text\": \"Welcome \\${username}! You selected \\${language} as your preferred language.\"\n    }\n  ]\n}\nEOM\n\ncurl -X POST ${ADD_ENDPOINT} \\\n  -H \"Authorization: Bearer ${TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d \"${DATA}\"\n</code></pre>"},{"location":"resources-rest-api-guide/#2-update-an-existing-resource","title":"2. Update an Existing Resource","text":"<p>Update the properties or contents of an existing resource.</p> <p>Endpoint: <code>PUT /update-resource/:name</code></p> <p>URL Parameters: - <code>:name</code> - The name of the resource to update</p> <p>Headers: - <code>Authorization: Bearer &lt;token&gt;</code> - Authentication token - <code>Content-Type: application/json</code> - Content type</p> <p>Request Body: Same format as for adding a resource, but must include the same name as in the URL</p> <p>Success Response: - Status Code: 200 - Body:   <pre><code>{\n  \"message\": \"\ud83c\udf89 Resource server-info updated successfully\",\n  \"oldType\": \"static\",\n  \"newType\": \"static\",\n  \"resource\": { ... } // The updated resource\n}\n</code></pre></p> <p>Error Responses: - Status Code: 400 - Missing or invalid resource data - Status Code: 403 - Invalid authentication token - Status Code: 404 - Resource not found - Status Code: 500 - Server error</p> <p>cURL Example:</p> <pre><code>#!/bin/bash\nTOKEN=\"wasimancer-rocks\"\nRESOURCE_NAME=\"server-info\"\n\nUPDATE_ENDPOINT=\"http://localhost:3001/update-resource/${RESOURCE_NAME}\"\n\nread -r -d '' DATA &lt;&lt;- EOM\n{\n  \"name\": \"server-info\",\n  \"uri\": \"config://server-details\",\n  \"contents\": [\n    {\n      \"text\": \"Updated server configuration details\",\n      \"version\": \"1.1.0\",\n      \"environment\": \"production\",\n      \"updatedAt\": \"2025-03-12\"\n    }\n  ]\n}\nEOM\n\ncurl -X PUT ${UPDATE_ENDPOINT} \\\n  -H \"Authorization: Bearer ${TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d \"${DATA}\"\n</code></pre>"},{"location":"resources-rest-api-guide/#3-remove-a-resource","title":"3. Remove a Resource","text":"<p>Remove a resource from the server.</p> <p>Endpoint: <code>DELETE /remove-resource/:name</code></p> <p>URL Parameters: - <code>:name</code> - The name of the resource to remove</p> <p>Headers: - <code>Authorization: Bearer &lt;token&gt;</code> - Authentication token</p> <p>Success Response: - Status Code: 200 - Body:   <pre><code>{\n  \"message\": \"\ud83d\ude42 Resource server-info removed successfully\",\n  \"type\": \"static\"\n}\n</code></pre></p> <p>Error Responses: - Status Code: 400 - Missing resource name - Status Code: 403 - Invalid authentication token - Status Code: 404 - Resource not found - Status Code: 500 - Server error</p> <p>cURL Example:</p> <pre><code>#!/bin/bash\nTOKEN=\"wasimancer-rocks\"\nRESOURCE_NAME=\"server-info\"\n\nREMOVE_ENDPOINT=\"http://localhost:3001/remove-resource/${RESOURCE_NAME}\"\n\ncurl -X DELETE ${REMOVE_ENDPOINT} \\\n  -H \"Authorization: Bearer ${TOKEN}\"\n</code></pre>"},{"location":"resources-rest-api-guide/#working-with-resources","title":"Working with Resources","text":""},{"location":"resources-rest-api-guide/#static-vs-dynamic-resources","title":"Static vs. Dynamic Resources","text":"<p>WASImancer automatically determines whether a resource is static or dynamic based on:</p> <ol> <li>Static Resource: URI with no parameters (doesn't contain curly braces <code>{}</code>), or doesn't have an <code>arguments</code> field</li> <li>Dynamic Resource: URI with parameters (contains one or more <code>{paramName}</code> segments) and has an <code>arguments</code> field</li> </ol>"},{"location":"resources-rest-api-guide/#resource-field-descriptions","title":"Resource Field Descriptions","text":""},{"location":"resources-rest-api-guide/#common-fields","title":"Common Fields","text":"<ul> <li><code>name</code>: A unique identifier for the resource</li> <li><code>uri</code>: URI for static resources or URI template for dynamic resources</li> <li><code>contents</code>: Array of content objects, each with at least a <code>text</code> field</li> </ul>"},{"location":"resources-rest-api-guide/#dynamic-resource-fields","title":"Dynamic Resource Fields","text":"<ul> <li><code>arguments</code>: Array of argument definitions for dynamic resources</li> <li><code>name</code>: Argument name (must match parameters in the URI template)</li> <li><code>type</code>: Argument type (for documentation purposes)</li> </ul>"},{"location":"resources-rest-api-guide/#best-practices","title":"Best Practices","text":""},{"location":"resources-rest-api-guide/#naming-conventions","title":"Naming Conventions","text":"<p>Use consistent, descriptive names for resources: - Use kebab-case for multi-word resource names (e.g., <code>server-config</code>, <code>user-profile</code>) - Use appropriate URI schemes (e.g., <code>config://</code>, <code>info://</code>, <code>data://</code>)</p>"},{"location":"resources-rest-api-guide/#resource-organization","title":"Resource Organization","text":"<p>Organize resources by purpose and keep them focused: - Group related information in a single resource - Prefer multiple content items over deeply nested JSON - Use clear, consistent structure across resources</p>"},{"location":"rust-plugin-guide/","title":"Creating Rust Plugins for WASImancer: A Step-by-Step Guide","text":"<p>\ud83d\udea7 work in progress</p> <p>This guide will walk you through the process of creating, building, and running a WebAssembly plugin for WASImancer using Rust. We'll create a simple calculator plugin that can add two numbers.</p>"},{"location":"rust-plugin-guide/#prerequisites","title":"Prerequisites","text":"<p>To follow this guide, you'll need:</p> <ul> <li>Rust and Cargo installed</li> <li>wasm32-unknown-unknown target for WebAssembly compilation</li> <li>Extism CLI for testing</li> </ul> <p>Alternatively, you can use the Docker image provided by WASImancer: <pre><code>docker pull k33g/wasm-builder:0.0.7\n</code></pre></p>"},{"location":"rust-plugin-guide/#project-setup","title":"Project Setup","text":"<p>Let's create a new Rust library project:</p> <pre><code>mkdir -p addition\ncd addition\n</code></pre>"},{"location":"rust-plugin-guide/#creating-the-rust-project","title":"Creating the Rust Project","text":"<p>Initialize a new Rust library project:</p> <pre><code>cargo init --lib\n</code></pre>"},{"location":"rust-plugin-guide/#configuring-the-project-for-webassembly","title":"Configuring the Project for WebAssembly","text":"<p>First, edit the <code>Cargo.toml</code> file to set up your project for WebAssembly compilation:</p> <pre><code>[package]\nname = \"wasimancer-plugin-addition\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\nextism-pdk = \"1.3.0\"\nserde = { version = \"1\", features = [\"derive\"] }\n</code></pre> <p>Key points about this configuration: - <code>crate-type = [\"cdylib\"]</code> specifies that we're building a dynamic library suitable for WebAssembly - <code>extism-pdk</code> is the Extism Plugin Development Kit for Rust - <code>serde</code> is used for serializing and deserializing JSON data</p> <p>Next, create a <code>.cargo/config.toml</code> file to set the default target:</p> <pre><code>[build]\ntarget = \"wasm32-unknown-unknown\"\n</code></pre>"},{"location":"rust-plugin-guide/#writing-the-plugin-code","title":"Writing the Plugin Code","text":"<p>Replace the contents of <code>src/lib.rs</code> with the following code:</p> <pre><code>use extism_pdk::*;\nuse serde::{Deserialize, Serialize};\n\n// Define input structure for addition\n#[derive(FromBytes, Deserialize, PartialEq, Debug)]\n#[encoding(Json)]\nstruct Add {\n    left: i32,\n    right: i32,\n}\n\n// Define output structure for the sum\n#[derive(ToBytes, Serialize, PartialEq, Debug)]\n#[encoding(Json)]\nstruct Sum {\n    value: i32,\n}\n\n#[plugin_fn]\npub fn add(input: Add) -&gt; FnResult&lt;Sum&gt; {\n    // Add the two numbers and return the result\n    Ok(Sum {\n        value: input.left + input.right,\n    })\n}\n</code></pre>"},{"location":"rust-plugin-guide/#understanding-the-code","title":"Understanding the Code","text":"<ol> <li> <p>We import the necessary components from <code>extism_pdk</code> and <code>serde</code> to handle WebAssembly interaction and JSON serialization.</p> </li> <li> <p>We define two structs:</p> </li> <li><code>Add</code>: Represents the input with two integers (<code>left</code> and <code>right</code>)</li> <li> <p><code>Sum</code>: Represents the output with a single integer (<code>value</code>)</p> </li> <li> <p>The <code>#[plugin_fn]</code> macro marks our <code>add</code> function as an exported plugin function.</p> </li> <li> <p>The <code>add</code> function takes an <code>Add</code> input, performs the addition, and returns a <code>Sum</code> result wrapped in <code>FnResult</code>.</p> </li> <li> <p>Both structs use the <code>#[encoding(Json)]</code> attribute to specify that they should be encoded/decoded as JSON.</p> </li> </ol>"},{"location":"rust-plugin-guide/#building-the-plugin","title":"Building the Plugin","text":""},{"location":"rust-plugin-guide/#using-local-rust","title":"Using Local Rust","text":"<p>To compile your Rust code to WebAssembly:</p> <pre><code>cargo build --release\n</code></pre> <p>The compiled WebAssembly file will be located at <code>target/wasm32-unknown-unknown/release/wasimancer_plugin_addition.wasm</code>.</p> <p>Copy it to your project directory:</p> <pre><code>cp target/wasm32-unknown-unknown/release/wasimancer_plugin_addition.wasm ./\n</code></pre>"},{"location":"rust-plugin-guide/#using-docker","title":"Using Docker","text":"<p>If you're using the WASImancer's Docker image:</p> <pre><code>docker run --rm -v \"$PWD\":/addition -w /addition k33g/wasm-builder:0.0.7 \\\n  bash -c \"\n    cargo clean &amp;&amp; \\\n    cargo install cargo-cache &amp;&amp; \\\n    cargo cache -a &amp;&amp; \\\n    cargo build --release &amp;&amp; \\\n    cp target/wasm32-unknown-unknown/release/wasimancer_plugin_addition.wasm ./\n  \"\n</code></pre>"},{"location":"rust-plugin-guide/#testing-the-plugin-locally","title":"Testing the Plugin Locally","text":"<p>You can test your plugin using the Extism CLI before deploying it to WASImancer:</p>"},{"location":"rust-plugin-guide/#using-local-extism-cli","title":"Using Local Extism CLI","text":"<pre><code>extism call wasimancer_plugin_addition.wasm add \\\n  --input '{\"left\":30, \"right\":12}' \\\n  --log-level \"info\" \\\n  --wasi\n</code></pre>"},{"location":"rust-plugin-guide/#using-docker_1","title":"Using Docker","text":"<pre><code>docker run --rm -v \"$PWD\":/addition -w /addition k33g/wasm-builder:0.0.7 \\\n  extism call wasimancer_plugin_addition.wasm add \\\n  --input '{\"left\":30, \"right\":12}' \\\n  --log-level \"info\" \\\n  --wasi\n</code></pre> <p>You should see output like: <code>{\"value\":42}</code>, indicating that the addition function correctly added 30 and 12.</p>"},{"location":"rust-plugin-guide/#creating-the-plugin-configuration","title":"Creating the Plugin Configuration","text":"<p>To use your plugin with WASImancer, you need to create a configuration in the <code>plugins.yml</code> file. Add the following entry:</p> <pre><code>plugins:\n  - name: addition\n    path: /addition/wasimancer_plugin_addition.wasm\n    version: 1.0.0\n    description: addition\n    functions:\n      - displayName: add with rust\n        function: add\n        arguments:\n          - name: left\n            type: number\n            description: first number\n          - name: right\n            type: number\n            description: second number\n        description: a function to add numbers\n</code></pre>"},{"location":"rust-plugin-guide/#deploying-the-plugin-to-wasimancer","title":"Deploying the Plugin to WASImancer","text":""},{"location":"rust-plugin-guide/#method-1-manual-deployment","title":"Method 1: Manual Deployment","text":"<ol> <li> <p>Copy your WebAssembly file to the WASImancer plugins directory:    <pre><code>cp wasimancer_plugin_addition.wasm /path/to/wasimancer/plugins/addition/\n</code></pre></p> </li> <li> <p>Restart WASImancer or use the hot-reload API (next method).</p> </li> </ol>"},{"location":"rust-plugin-guide/#method-2-using-the-upload-api","title":"Method 2: Using the Upload API","text":"<p>You can use the WASImancer API to upload your plugin without restarting the server:</p> <ol> <li>Create a shell script named <code>publish.sh</code> with the following content:</li> </ol> <pre><code>#!/bin/bash\nTOKEN=\"wasimancer-rocks\"  # Use your configured token\n\nUPLOAD_ENDPOINT=\"http://localhost:3001/upload-plugin\"\nWASM_FILE=\"./wasimancer_plugin_addition.wasm\"\n\nread -r -d '' DATA &lt;&lt;- EOM\n{\n  \"name\": \"addition\",\n  \"path\": \"./bucket/wasimancer_plugin_addition.wasm\",\n  \"version\": \"1.0.0\",\n  \"description\": \"addition\",\n  \"functions\": [\n    {\n      \"displayName\": \"add with rust\",\n      \"function\": \"add\",\n      \"arguments\": [\n        {\n          \"name\": \"left\",\n          \"type\": \"number\",\n          \"description\": \"first number\"\n        },\n        {\n          \"name\": \"right\",\n          \"type\": \"number\",\n          \"description\": \"second number\"\n        }\n      ],\n      \"description\": \"a function to add numbers\"\n    }\n  ]\n}\nEOM\n\ncurl -X POST ${UPLOAD_ENDPOINT} \\\n  -H \"Authorization: Bearer ${TOKEN}\" \\\n  -F \"wasmFile=@${WASM_FILE}\" \\\n  -F \"pluginData=${DATA}\"\n</code></pre> <ol> <li>Make the script executable and run it:    <pre><code>chmod +x publish.sh\n./publish.sh\n</code></pre></li> </ol>"},{"location":"rust-plugin-guide/#testing-the-plugin-in-wasimancer","title":"Testing the Plugin in WASImancer","text":"<p>You can test your deployed plugin using the MCP Inspector:</p> <ol> <li> <p>Start the Inspector:    <pre><code>npx @modelcontextprotocol/inspector\n</code></pre></p> </li> <li> <p>Connect to your WASImancer instance (typically at <code>http://localhost:3001/sse</code>).</p> </li> <li> <p>Navigate to the \"Tools\" tab, find your plugin, and click \"Run Tool\".</p> </li> </ol>"},{"location":"rust-plugin-guide/#debugging-tips-for-rust-plugins","title":"Debugging Tips for Rust Plugins","text":"<ol> <li> <p>Extism Logging: The Extism PDK provides logging functions:    <pre><code>extism_pdk::log::info!(\"Processing calculation: {} {} {}\", input.a, input.operation, input.b);\n</code></pre></p> </li> <li> <p>Test with <code>--log-level \"debug\"</code> or <code>--log-level \"trace\"</code> flags: When using the Extism CLI, increase the log level for more details.</p> </li> <li> <p>Validate JSON Parsing: If you're having issues with JSON parsing, try adding explicit error handling:    <pre><code>#[plugin_fn]\npub fn calculate(json: String) -&gt; FnResult&lt;String&gt; {\n    // Manual parsing with explicit error handling\n    let input: CalcInput = match serde_json::from_str(&amp;json) {\n        Ok(val) =&gt; val,\n        Err(e) =&gt; return Err(Error::new(&amp;format!(\"JSON parse error: {}\", e))),\n    };\n\n    // Process as before...\n}\n</code></pre></p> </li> </ol>"},{"location":"rust-plugin-guide/#best-practices-for-rust-plugins","title":"Best Practices for Rust Plugins","text":"<ol> <li> <p>Leverage Rust's Type System: Use Rust's strong type system to prevent bugs and make your code more maintainable.</p> </li> <li> <p>Use <code>Result</code> for Error Handling: Return meaningful errors rather than panicking, which can cause unexpected behavior in WebAssembly.</p> </li> <li> <p>Keep Dependencies Minimal: Large dependencies can increase your WebAssembly module size and slow down loading times.</p> </li> <li> <p>Optimize for Size: Use build flags to optimize for smaller WebAssembly modules:    <pre><code>[profile.release]\nlto = true\nopt-level = 's'\n</code></pre></p> </li> <li> <p>Use Rust's Memory Management: Take advantage of Rust's ownership model to prevent memory leaks, which is especially important in long-running WebAssembly modules.</p> </li> <li> <p>Document Your Code: Add thorough documentation comments to make your plugins easier to maintain.</p> </li> </ol>"},{"location":"rust-plugin-guide/#build-script-for-convenience","title":"Build Script for Convenience","text":"<p>Create a <code>build.sh</code> script to simplify the build process:</p> <pre><code>#!/bin/bash\ncargo clean\ncargo build --release\ncp target/wasm32-unknown-unknown/release/wasimancer_plugin_addition.wasm ./\nls -lh *.wasm\n</code></pre> <p>And a <code>run.sh</code> script to test your plugin:</p> <pre><code>#!/bin/bash\nextism call wasimancer_plugin_addition.wasm add \\\n  --input '{\"left\":30, \"right\":12}' \\\n  --log-level \"info\" \\\n  --wasi\necho \"\"\n</code></pre> <p>Make them executable: <pre><code>chmod +x build.sh run.sh\n</code></pre></p>"},{"location":"rust-plugin-guide/#conclusion","title":"Conclusion","text":"<p>You've now learned how to create, build, test, and deploy a Rust plugin for WASImancer. Rust's combination of safety, performance, and WebAssembly support makes it an excellent choice for developing WASImancer plugins. By leveraging Rust's rich ecosystem and type system, you can create powerful, secure tools that enhance your AI applications through the Model Context Protocol.</p>"},{"location":"test-with-curl/","title":"WASImancer MCP StreamableHTTP Server Testing Guide (with curl)","text":"<p>Info</p> <p>This document explains how to test the WASImancer MCP (Model Control Protocol) StreamableHTTP Server using the provided shell scripts.</p>"},{"location":"test-with-curl/#prerequisites","title":"Prerequisites","text":"<ul> <li>A running WASImancer MCP StreamableHTTP Server (default: http://localhost:3001)</li> <li>Authentication token (default: mcp-is-the-way)</li> <li>curl and jq installed on your system</li> </ul>"},{"location":"test-with-curl/#configuration","title":"Configuration","text":"<p>All scripts use the following common configuration:</p> <pre><code>MCP_SERVER=http://localhost:3001\nAUTHENTICATION_TOKEN=mcp-is-the-way\n</code></pre> <p>Look at the <code>./tests</code> folder for the scripts.</p>"},{"location":"test-with-curl/#available-testing-scripts","title":"Available Testing Scripts","text":""},{"location":"test-with-curl/#listing-available-resources","title":"Listing Available Resources","text":"<ol> <li>List Available Tools</li> </ol> <pre><code>MCP_SERVER=http://localhost:3001\nAUTHENTICATION_TOKEN=mcp-is-the-way\n\nread -r -d '' DATA &lt;&lt;- EOM\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"tools/list\",\n  \"params\": {}\n}\nEOM\n\ncurl ${MCP_SERVER}/mcp \\\n  -H \"Authorization: Bearer ${AUTHENTICATION_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Accept: application/json, text/event-stream\" \\\n  -d \"${DATA}\" \\\n  | grep \"^data:\" | sed 's/^data: //' | jq '.'\n</code></pre> <p>Lists all available tools that can be called through the MCP server.</p> <ol> <li>List Resource Templates</li> </ol> <pre><code>MCP_SERVER=http://localhost:3001\nAUTHENTICATION_TOKEN=mcp-is-the-way\n\nread -r -d '' DATA &lt;&lt;- EOM\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"resources/templates/list\",\n  \"params\": {}\n}\nEOM\n\ncurl ${MCP_SERVER}/mcp \\\n  -H \"Authorization: Bearer ${AUTHENTICATION_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Accept: application/json, text/event-stream\" \\\n  -d \"${DATA}\" \\\n  | grep \"^data:\" | sed 's/^data: //' | jq '.'\n</code></pre> <p>Lists all available resource templates that can be used.</p> <ol> <li>List Resources</li> </ol> <pre><code>MCP_SERVER=http://localhost:3001\nAUTHENTICATION_TOKEN=mcp-is-the-way\n\n\nread -r -d '' DATA &lt;&lt;- EOM\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"resources/list\",\n  \"params\": {}\n}\nEOM\n\ncurl ${MCP_SERVER}/mcp \\\n  -H \"Authorization: Bearer ${AUTHENTICATION_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Accept: application/json, text/event-stream\" \\\n  -d \"${DATA}\" \\\n  | grep \"^data:\" | sed 's/^data: //' | jq '.'\n</code></pre> <p>Lists all available resources that can be accessed.</p> <ol> <li>List Prompts</li> </ol> <pre><code>MCP_SERVER=http://localhost:3001\nAUTHENTICATION_TOKEN=mcp-is-the-way\n\nread -r -d '' DATA &lt;&lt;- EOM\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"prompts/list\",\n  \"params\": {}\n}\nEOM\n\ncurl ${MCP_SERVER}/mcp \\\n  -H \"Authorization: Bearer ${AUTHENTICATION_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Accept: application/json, text/event-stream\" \\\n  -d \"${DATA}\" \\\n  | grep \"^data:\" | sed 's/^data: //' | jq '.'\n</code></pre> <p>Lists all available prompts that can be used.</p>"},{"location":"test-with-curl/#using-tools","title":"Using Tools","text":"<ol> <li>Roll Dice Tool</li> </ol> <pre><code>MCP_SERVER=http://localhost:3001\nAUTHENTICATION_TOKEN=mcp-is-the-way\n\nread -r -d '' DATA &lt;&lt;- EOM\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"rollDice\",\n    \"arguments\": {\n      \"numDice\": 3,\n      \"numFaces\": 6\n    }\n  }\n}\nEOM\n\ncurl ${MCP_SERVER}/mcp \\\n  -H \"Authorization: Bearer ${AUTHENTICATION_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Accept: application/json, text/event-stream\" \\\n  -d \"${DATA}\" \\\n  | grep \"^data:\" | sed 's/^data: //' | jq '.'\n</code></pre> <p>Calls the <code>rollDice</code> tool with parameters to roll 3 dice with 6 faces each.</p> <ol> <li>Addition Tool</li> </ol> <pre><code>MCP_SERVER=http://localhost:3001\nAUTHENTICATION_TOKEN=mcp-is-the-way\n\nread -r -d '' DATA &lt;&lt;- EOM\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"add with rust\",\n    \"arguments\": {\n      \"left\": 23,\n      \"right\": 19\n    }\n  }\n}\nEOM\n\ncurl ${MCP_SERVER}/mcp \\\n  -H \"Authorization: Bearer ${AUTHENTICATION_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Accept: application/json, text/event-stream\" \\\n  -d \"${DATA}\" \\\n  | grep \"^data:\" | sed 's/^data: //' | jq '.'\n</code></pre> <p>Calls the <code>add with rust</code> tool to add two numbers (23 + 19).</p>"},{"location":"test-with-curl/#accessing-resources","title":"Accessing Resources","text":"<ol> <li>Access Resource Template</li> </ol> <pre><code>MCP_SERVER=http://localhost:3001\nAUTHENTICATION_TOKEN=mcp-is-the-way\n\nread -r -d '' DATA &lt;&lt;- EOM\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"resources/read\",\n  \"params\": {\n    \"uri\": \"greet-user://Bob/Morane\"\n  }\n}\nEOM\n\ncurl ${MCP_SERVER}/mcp \\\n  -H \"Authorization: Bearer ${AUTHENTICATION_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Accept: application/json, text/event-stream\" \\\n  -d \"${DATA}\" \\\n  | grep \"^data:\" | sed 's/^data: //' | jq '.'\n</code></pre> <p>Reads a resource using a template URI: <code>greet-user://Bob/Morane</code></p> <ol> <li>Access Resource</li> </ol> <pre><code>MCP_SERVER=http://localhost:3001\nAUTHENTICATION_TOKEN=mcp-is-the-way\n\nread -r -d '' DATA &lt;&lt;- EOM\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"resources/read\",\n  \"params\": {\n    \"uri\": \"config://server\"\n  }\n}\nEOM\n\ncurl ${MCP_SERVER}/mcp \\\n  -H \"Authorization: Bearer ${AUTHENTICATION_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Accept: application/json, text/event-stream\" \\\n  -d \"${DATA}\" \\\n  | grep \"^data:\" | sed 's/^data: //' | jq '.'\n</code></pre> <p>Reads a resource directly using the URI: <code>config://server</code></p>"},{"location":"test-with-curl/#using-prompts","title":"Using Prompts","text":"<ol> <li>Use Prompt</li> </ol> <pre><code>MCP_SERVER=http://localhost:3001\nAUTHENTICATION_TOKEN=mcp-is-the-way\n\nread -r -d '' DATA &lt;&lt;- EOM\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1\",\n  \"method\": \"prompts/get\",\n  \"params\": {\n    \"name\": \"greet-user\",\n    \"arguments\": {\n      \"nickName\": \"Bob Morane\"\n    }  \n  }\n}\nEOM\n\ncurl ${MCP_SERVER}/mcp \\\n  -H \"Authorization: Bearer ${AUTHENTICATION_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Accept: application/json, text/event-stream\" \\\n  -d \"${DATA}\" \\\n  | grep \"^data:\" | sed 's/^data: //' | jq '.'\n</code></pre> <p>Gets a prompt named \"greet-user\" with an argument for the nickname.</p>"},{"location":"test-with-curl/#json-rpc-structure","title":"JSON-RPC Structure","text":"<p>All requests follow the JSON-RPC 2.0 specification with:</p> <ul> <li><code>jsonrpc</code>: Always \"2.0\"</li> <li><code>id</code>: Request identifier</li> <li><code>method</code>: The API method to call</li> <li><code>params</code>: Method-specific parameters</li> </ul>"},{"location":"test-with-curl/#response-processing","title":"Response Processing","text":"<p>All scripts process the server response with:</p> <pre><code>curl ${MCP_SERVER}/mcp \\\n  -H \"Authorization: Bearer ${AUTHENTICATION_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Accept: application/json, text/event-stream\" \\\n  -d \"${DATA}\" \\\n  | grep \"^data:\" | sed 's/^data: //' | jq '.'\n</code></pre> <p>This: 1. Sends a POST request to the server 2. Sets appropriate headers including authentication 3. Filters response stream data with <code>grep \"^data:\"</code> 4. Removes the <code>data:</code> prefix with <code>sed</code> 5. Pretty-prints the JSON with <code>jq</code></p>"},{"location":"test-with-curl/#creating-your-own-tests","title":"Creating Your Own Tests","text":"<p>To create a new test script:</p> <ol> <li>Copy an existing script as a template</li> <li>Modify the <code>method</code> and <code>params</code> in the JSON data</li> <li>Make the script executable with <code>chmod +x your-script.sh</code></li> <li>Run with <code>./your-script.sh</code></li> </ol>"},{"location":"test-with-curl/#common-methods","title":"Common Methods","text":"<ul> <li><code>tools/list</code>: List available tools</li> <li><code>tools/call</code>: Call a tool with arguments</li> <li><code>resources/templates/list</code>: List resource templates</li> <li><code>resources/list</code>: List available resources</li> <li><code>resources/read</code>: Read a resource with a specific URI</li> <li><code>prompts/list</code>: List available prompts</li> <li><code>prompts/get</code>: Get a specific prompt with arguments</li> </ul>"},{"location":"test-with-curl/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Check that the server is running at the specified address</li> <li>Verify that the authentication token is correct</li> <li>Ensure the <code>curl</code> and <code>jq</code> commands are available in your environment</li> <li>Examine the full response for error messages if parsing fails</li> </ul>"},{"location":"wasm-plugins-concept/","title":"Understanding WebAssembly Plugins in WASImancer","text":"<p>\ud83d\udea7 work in progress</p>"},{"location":"wasm-plugins-concept/#what-are-webassembly-plugins","title":"What are WebAssembly Plugins?","text":"<p>In WASImancer, WebAssembly (WASM) plugins are the building blocks that enable the MCP server to execute tools. These plugins are compiled WebAssembly modules that:</p> <ol> <li>Contain one or more functions that can be called by the MCP server</li> <li>Run in a sandboxed environment for security</li> <li>Execute at near-native speed</li> <li>Can be written in multiple programming languages</li> </ol> <p>WebAssembly serves as a portable compilation target, allowing developers to write code in their preferred language (Go, Rust, C++, etc.) and compile it to a standard binary format that can be executed in WASImancer.</p>"},{"location":"wasm-plugins-concept/#how-plugins-work-in-wasimancer","title":"How Plugins Work in WASImancer","text":""},{"location":"wasm-plugins-concept/#plugin-architecture","title":"Plugin Architecture","text":"<p>WASImancer uses the Extism framework to load and execute WebAssembly plugins. The architecture follows these principles:</p> <ol> <li>Isolation: Each plugin runs in its own isolated environment</li> <li>Communication: Data is passed between the host (WASImancer) and the plugin via function parameters and return values</li> <li>Registration: Plugins are registered with the MCP server and exposed as tools</li> <li>Execution: When a client requests a tool, the server calls the corresponding function in the WASM plugin</li> </ol>"},{"location":"wasm-plugins-concept/#plugin-definition-in-yaml","title":"Plugin Definition in YAML","text":"<p>Plugins are defined in the <code>plugins.yml</code> file, which maps WebAssembly modules to MCP tools:</p> <pre><code>plugins:\n  - name: roll dice           # Name of the plugin\n    path: ./roll-dice/wasimancer-plugin-roll-dice.wasm  # Path to the WASM file\n    version: 1.0.0            # Version information\n    description: roll dice     # Description of the plugin\n    functions:\n      - displayName: rollDice  # The tool name exposed to clients\n        function: rollDice     # The exported function in the WASM module\n        arguments:             # Input parameters for the function\n          - name: numFaces\n            type: number\n            description: number of faces on the dice\n          - name: numDice\n            type: number\n            description: number of dice to roll\n        description: a function to roll dice  # Tool description\n</code></pre> <p>This configuration: 1. Tells WASImancer where to find the WASM module 2. Defines which functions to expose as tools 3. Specifies the expected input parameters 4. Provides descriptions for documentation</p>"},{"location":"wasm-plugins-concept/#plugin-development","title":"Plugin Development","text":""},{"location":"wasm-plugins-concept/#supported-languages","title":"Supported Languages","text":"<p>You can develop plugins for WASImancer in any language that compiles to WebAssembly with WASI support. Commonly used languages include:</p> <ul> <li>Go (using TinyGo)</li> <li>Rust</li> <li>C/C++</li> <li>AssemblyScript</li> </ul>"},{"location":"wasm-plugins-concept/#development-workflow","title":"Development Workflow","text":"<ol> <li>Write your plugin code in your preferred language</li> <li>Compile to WebAssembly using the appropriate toolchain</li> <li>Test locally using the Extism CLI</li> <li>Deploy to WASImancer by placing the WASM file in the plugins directory</li> <li>Configure in plugins.yml to expose your functions as tools</li> </ol>"},{"location":"wasm-plugins-concept/#example-go-plugin","title":"Example: Go Plugin","text":"<p>Here's a simple plugin written in Go that rolls dice:</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"math/rand\"\n    \"strconv\"\n\n    \"github.com/extism/go-pdk\"\n)\n\ntype Arguments struct {\n    NumFaces int `json:\"numFaces\"`\n    NumDice  int `json:\"numDice\"`\n}\n\n//export rollDice\nfunc rollDice() {\n    // Get input arguments as a JSON string\n    arguments := pdk.InputString()\n\n    // Parse the arguments\n    var args Arguments\n    json.Unmarshal([]byte(arguments), &amp;args)\n    numFaces := args.NumFaces \n    numDice := args.NumDice\n\n    // Roll the dice\n    sum := 0\n    for i := 0; i &lt; numDice; i++ {\n        dieValue := rand.Intn(numFaces) + 1\n        sum += dieValue\n    }\n\n    // Return the result\n    pdk.OutputString(strconv.Itoa(sum))\n}\n\nfunc main() {\n    // Required for WebAssembly modules but not used\n}\n</code></pre>"},{"location":"wasm-plugins-concept/#compiling-with-tinygo","title":"Compiling with TinyGo","text":"<p>To compile a Go plugin, use TinyGo with the WASI target:</p> <pre><code>tinygo build -scheduler=none --no-debug \\\n  -o wasimancer-plugin-roll-dice.wasm \\\n  -target wasi main.go\n</code></pre>"},{"location":"wasm-plugins-concept/#json-communication-protocol","title":"JSON Communication Protocol","text":"<p>Plugins in WASImancer communicate using a JSON-based protocol:</p> <ol> <li>Input: Function arguments are passed as JSON strings</li> <li>Output: Function results are returned as text (often JSON or simple values)</li> </ol> <p>For example, when calling the <code>rollDice</code> function: - Input: <code>{\"numFaces\": 6, \"numDice\": 2}</code> - Output: <code>\"8\"</code> (the sum of the dice roll)</p>"},{"location":"wasm-plugins-concept/#plugin-lifecycle-management","title":"Plugin Lifecycle Management","text":"<p>WASImancer provides several REST API endpoints to manage plugins at runtime:</p>"},{"location":"wasm-plugins-concept/#upload-a-new-plugin","title":"Upload a New Plugin","text":"<pre><code>POST /upload-plugin\nHeaders: Authorization: Bearer &lt;token&gt;\nBody: multipart/form-data with wasmFile and pluginData\n</code></pre>"},{"location":"wasm-plugins-concept/#replace-an-existing-plugin","title":"Replace an Existing Plugin","text":"<pre><code>PUT /update-plugin\nHeaders: Authorization: Bearer &lt;token&gt;\nBody: multipart/form-data with wasmFile and pluginData\n</code></pre>"},{"location":"wasm-plugins-concept/#remove-a-plugin","title":"Remove a Plugin","text":"<pre><code>DELETE /remove-plugin/&lt;name&gt;\nHeaders: Authorization: Bearer &lt;token&gt;\n</code></pre> <p>These APIs enable hot-reloading of plugins without restarting the server.</p>"},{"location":"wasm-plugins-concept/#best-practices-for-plugin-development","title":"Best Practices for Plugin Development","text":"<ol> <li>Keep plugins focused: Each plugin should have a specific purpose</li> <li>Handle errors gracefully: Return meaningful error messages when things go wrong</li> <li>Validate inputs: Check input parameters for validity before processing</li> <li>Use appropriate types: Match function parameter types with their expected usage</li> <li>Document thoroughly: Provide clear descriptions for your plugin and its functions</li> <li>Test independently: Use the Extism CLI to test plugins before deploying to WASImancer</li> </ol>"},{"location":"wasm-plugins-concept/#security-considerations","title":"Security Considerations","text":"<p>WebAssembly plugins run in a sandboxed environment, but you should still follow these security guidelines:</p> <ol> <li>Limit permissions: Only grant the permissions a plugin needs (e.g., network access, file system access)</li> <li>Validate inputs: Always validate and sanitize inputs to prevent injection attacks</li> <li>Protect sensitive data: Be careful about handling sensitive information within plugins</li> <li>Update dependencies: Keep your plugin dependencies up to date to address security vulnerabilities</li> </ol>"},{"location":"wasm-plugins-concept/#debugging-plugins","title":"Debugging Plugins","text":"<p>When developing plugins, you can use:</p> <ol> <li> <p>Extism CLI: Test your plugin locally before deploying    <pre><code>extism call wasimancer-plugin-roll-dice.wasm rollDice \\\n  --input '{\"numFaces\":6,\"numDice\":2}' \\\n  --log-level \"info\" \\\n  --wasi\n</code></pre></p> </li> <li> <p>Inspector Tool: Test your plugins once deployed to WASImancer    <pre><code>npx @modelcontextprotocol/inspector\n</code></pre></p> </li> </ol> <p>By embracing WebAssembly plugins, WASImancer provides a powerful, flexible, and secure way to extend MCP servers with custom functionality in any programming language.</p>"}]}